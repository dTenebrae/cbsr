#!/home/tenebrae/devel/cbsr/venv/bin/python3

import re
import os
import json
import shutil
import urllib3
# import vulners
import requests
import argparse
import subprocess
import redminelib
from time import sleep
from pathlib import Path
import urllib.parse as parse
from bs4 import BeautifulSoup
from redminelib import Redmine
from collections import Counter
from dotenv import dotenv_values
from urllib.parse import urljoin
from datetime import timedelta, date, datetime
from pkg_handlers import USERS_LIST, PkgHandler, compare_versions, IsXIssue, PatchResult

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
os.chdir("/home/tenebrae/devel/cbsr/")

# ############################ КОНСТАНТЫ #############################
NUMBER_OF_RECON = 5

REPO_PATH = '/mnt/ssd/koji/packages'

NIST_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
NIST_CVE = "cveId"
NIST_REJ = "noRejected"
NIST_START = "pubStartDate"
NIST_END = "pubEndDate"

KERNEL_PATH = f"{os.path.expanduser('.')}/src"
TMP_PATCHES_PATH = f"{os.getcwd()}/output/tmp-patches"
DEST_PATCH_PATH = f"{os.getcwd()}/output/patches"

# Явки/пароли для трекера
credentials = dotenv_values(".env")
REDMINE_URL = "https://tracker.red-soft.ru"

HEADERS = {
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,'
              'application/signed-exchange;v=b3;q=0.9',
    'Accept-Language': 'en-US,en;q=0.9,ru;q=0.8',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) '
                  'Chrome/102.0.5005.167 Safari/537.36',
}


# ######################################################################


class CveChecker:

    @staticmethod
    def __redmine_auth():
        """
        Простой wrapper для авторизации
        """
        redmine = Redmine(REDMINE_URL,
                          username=credentials['REDMINE_USER'],
                          password=credentials['REDMINE_PASSWORD'])
        try:
            redmine.auth()
            return redmine
        except redminelib.exceptions.AuthError:
            print("Auth Failed")
            return None

    # @staticmethod
    # def __vulners_auth():
    #     vulners_api = vulners.VulnersApi(api_key=credentials['VULNERS_KEY'])
    #     return vulners_api

    @staticmethod
    def exec_bash(bash_cmd: str) -> str:
        """
        Простая обертка для выполнения bash-команд
        :param bash_cmd: Команда в строковом формате
        :return: Возвращает результат выполнения в UTF-8 кодировке
        """
        ps = subprocess.Popen(bash_cmd,
                              shell=True,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.DEVNULL)
        return ps.communicate()[0].decode('utf-8')

    @staticmethod
    def grep_cve(text) -> list:
        regex = re.compile(r"[A-Z]{3}.{0,2}-\d{4}-\d{4,7}")
        return re.findall(regex, text)

    def download_kernel_src(self, kern_ver: str):
        """
        Качаем сорцы ядра требуемой версии и распаковываем
        :param kern_ver: версия ядра
        :return:
        """
        # TODO сделать под разные мажорные версии ядер
        kern_src_url = f"https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-{kern_ver}.tar.xz"
        kernel_src_filename = f"{KERNEL_PATH}/linux-{kern_ver}.tar.xz"

        # Качаем архив
        req = self.get_response(kern_src_url, bs=False)
        with open(kernel_src_filename, "wb") as f:
            for chunk in req.iter_content(100000):
                f.write(chunk)

        # Распаковываем в папку и удаляем архив
        unpack_cmd = f"tar xf {kernel_src_filename} -C {KERNEL_PATH}"
        rm_cmd = f"rm -f {kernel_src_filename}"
        self.exec_bash(unpack_cmd)
        self.exec_bash(rm_cmd)

    def __prepare_dirs_and_paths(self):
        """
        Проверяем на существование требуемые папки
        """
        if not os.path.exists(KERNEL_PATH):
            os.makedirs(KERNEL_PATH)

        if not os.path.exists(USERS_LIST):
            self.get_users_list()

        for kernel_data in self.pkg_handler.pkgs_data['kernel']['nvr_list']:
            self.kernel_paths.append(f"{KERNEL_PATH}/linux-{kernel_data}")
            if not os.path.exists(f"{DEST_PATCH_PATH}/patches-{kernel_data}"):
                os.makedirs(f"{DEST_PATCH_PATH}/patches-{kernel_data}")

        # если нет сорцов для какой либо версии проверяемых ядер - скачиваем и распаковываем их
        for kern_path in set(self.kernel_paths):
            if not os.path.exists(kern_path):
                print(f"Downloading sources for linux kernel: {kern_path}")
                self.download_kernel_src(kern_path)

        if os.path.exists(TMP_PATCHES_PATH):
            shutil.rmtree(TMP_PATCHES_PATH, ignore_errors=False, onerror=None)
        os.makedirs(TMP_PATCHES_PATH)

    def __init__(self, days_to_check, recon_num, auto):

        self.redmine = self.__redmine_auth()
        # self.vulners = self.__vulners_auth()

        self.pkg_handler = PkgHandler()
        self.days_to_check = days_to_check
        self.recon_num = recon_num
        self.auto = auto
        self.manual_check = []
        self.kernel_paths = []

        self.__prepare_dirs_and_paths()

    @staticmethod
    def get_response(*args, bs=True, parser='lxml', **kwargs):
        """
        Получим ответ по url
        * bs - вернуть как soup или обычные response
        * parser - какой парсер страницы используем (html, xml, lxml)
        * NUMBER_OF_RECON - глобальная опция. Сколько стучимся, если поймали ошибку соединения
        """
        recon_count = 0
        while recon_count <= NUMBER_OF_RECON:
            try:
                response: requests.Response = requests.get(*args, **kwargs)
                # проверим код ответа
                if response.status_code != requests.codes.ok:
                    raise ConnectionError
                sleep(0.1)
                if bs:
                    return BeautifulSoup(response.text, parser)
                else:
                    return response
            except ConnectionError:
                # Стучимся пока не соединимся.
                sleep(0.250)
                recon_count += 1
        print(f'Ошибка соединения')

    def is_cve_exists_rest_api(self, cve: str) -> bool:
        """
        Костыльная проверка на существование CVE в трекере.
        Используется, пока не разберусь с оберткой redminelib
        """
        url = f"{REDMINE_URL}/projects/cve/search.xml?&issues=1&q={cve}"
        # Так как редмайн ищет все вхождения подстроки, мы можем
        # проигнорировать CVE сами того не желая.
        # Например: CVE-2023-1281 при наличии на трекере CVE-2023-12811
        # посчитается как существующая
        exact_search_re = re.compile(fr"\b{cve}\b", re.I)

        resp = self.get_response(url,
                                 bs=True,
                                 parser='xml',
                                 headers=HEADERS,
                                 auth=(credentials['REDMINE_USER'], credentials['REDMINE_PASSWORD'])
                                 )
        # Найдем, сколько раз CVE встречается в поиске
        f_count = resp.find("results").get("total_count")
        try:
            if int(f_count):
                return bool(exact_search_re.findall(resp.find("description").text))
            return False
        except ValueError:
            print("Ошибка поиска")
            return False

    def get_users_list(self):
        """
        создает файл со списком юзеров трекера с их номерами
        :return:
        """
        result = {}
        url = f"{REDMINE_URL}/users?per_page=500"
        resp = self.get_response(url,
                                 bs=True,
                                 parser='xml',
                                 headers=HEADERS,
                                 auth=(credentials['REDMINE_USER'], credentials['REDMINE_PASSWORD'])
                                 )
        for user in resp.find_all('td', attrs={'class': 'login'}):
            user_lnk = user.find('a')
            if user_lnk.text:
                result[user_lnk.text] = int(re.findall(r"\d+", user_lnk.get('href'))[0])
        with open(USERS_LIST, 'w') as f:
            json.dump(result, f)
        print(f"Данные пользователей записаны в {USERS_LIST}")

    def create_mozcve(self, url) -> dict:
        cve_dict = {}
        resp = self.get_response(url,
                                 bs=True,
                                 parser='lxml',
                                 headers=HEADERS,
                                 )
        # Парсим summary в словарь
        main_sum = resp.find('dl', attrs={'class', 'summary'})
        for name, item in zip(main_sum.find_all('dt'), main_sum.find_all('dd')):
            cve_dict["_".join(name.text.lower().split())] = item.text.strip()
        cve_dict['cves'] = []
        for cve in resp.find_all('section', attrs={'class', 'cve'}):
            cve_header = list(map(str.strip, cve.find('a').text[1:].split(':', 1)))
            cve_dict['cves'].append({
                'id': cve_header[0],
                'name': cve_dict['products'].lower().split(',')[0],
                'vuln_products': cve_dict['products'],
                'fixed_in': cve_dict['fixed_in'],
                'description': f"*{cve_header[1]}*\n{cve.find('p').text}",
                'impact': cve.find('span', attrs={'class', 'level'}).text,
                'links': [link.find("a").get("href")
                          for link in cve.find_all('li')],
                'source': f"{url}#{cve_header[0]}",
            })
        return cve_dict

    def get_mozilla_cves(self, n=3):
        """
        Собираем cve с мозилловского блога
        :param n - количество последних проверяемых ссылок.
        В противном случае придется обрабатывать более 1300 старых ссылок
        """
        url = "https://www.mozilla.org/en-US/security/advisories/"
        resp = self.get_response(url,
                                 bs=True,
                                 parser='lxml',
                                 headers=HEADERS,
                                 )
        visited_urls = []
        if os.path.exists('./visited_urls.log'):
            # Загружаем список уже посещенных урлов
            with open('./visited_urls.log', 'r') as url_file:
                visited_urls = list(map(str.strip, url_file.readlines()))
        result = []
        cnt = 0
        for link in resp.find_all('li', attrs={'class', 'level-item'}):
            if cnt >= n:
                break
            href = link.find('a')
            if href:
                cnt += 1
                link = urljoin('https://www.mozilla.org', href.get('href', ""))
                if link in visited_urls:
                    continue
                # добавляем новый урл в список посещенных
                result.append(self.create_mozcve(link))
                with open('./visited_urls.log', 'a') as url_file:
                    url_file.write(f"{link}\n")
        return result

    def get_zero_cves(self) -> list:

        url = "https://www.zerodayinitiative.com/advisories/published/"
        resp = self.get_response(url,
                                 bs=True,
                                 parser='lxml',
                                 headers=HEADERS,
                                 )
        result = []
        for tr in resp.find_all("tr", attrs={"id": "publishedAdvisories"}):
            tds = tr.find_all("td")
            if tds[2].text.lower() == 'linux':
                current_url = f"https://www.zerodayinitiative.com/advisories/{tds[0].text}/"
                resp = self.get_response(current_url,
                                         bs=True,
                                         parser='lxml',
                                         headers=HEADERS,
                                         )
                table_tr_list = resp.find("table").find_all("tr")
                if table_tr_list[3].find_all("td")[1].text.strip().lower() == 'kernel':
                    long_desc = table_tr_list[4].find_all("td")[1].text.strip()
                    links = [url.text.strip() for url in table_tr_list[5].find_all("a")]
                    result.append({
                        "zdi_id": tds[0].text,
                        "name": 'kernel',
                        "zdi_can": tds[1].text,
                        "vendor": tds[2].text,
                        "id": tds[3].text if (tds[3].text and tds[3].text != '\xa0') else tds[1].text,
                        "cvss": tds[4].text,
                        "date": tds[5].text,
                        "updated": tds[6].text,
                        "short_desc": tds[7].text,
                        "description": long_desc,
                        "source": f"https://www.zerodayinitiative.com/advisories/{tds[0].text}/",
                        "links": links
                    })

        return result

    def find_all_issues(self, n=30):
        """
        Сканируем трекер, собираем большинство уязвимостей и печатаем n популярных
        """

        def title_strip(title):
            regex1 = re.compile(r"уязвимость в (.+)$", re.I)
            regex2 = re.compile(r"уязвимости в (.+)$", re.I)
            regex3 = re.compile(r"уязвимость: (.+)$", re.I)
            title_reg = re.findall(regex1, title.text)
            title_reg.extend(re.findall(regex2, title.text))
            title_reg.extend(re.findall(regex3, title.text))
            if title_reg:
                return title_reg[0].strip().lower()

        # ниже идут функции проверки на принадлежность к пакету
        def kernel_str(str_to_check: str) -> str:
            kw_list = [
                'ядро linux',
                'ядру linux',
                'ядра linux',
                'ядре linux',
                'linux-ядра',
            ]
            for kw in kw_list:
                if kw in str_to_check:
                    return 'linux kernel'
            return str_to_check

        def firefox_str(str_to_check: str) -> str:
            return 'firefox' if 'firefox' in str_to_check else str_to_check

        def systemd_str(str_to_check: str) -> str:
            return 'systemd' if 'systemd' in str_to_check else str_to_check

        def nextcloud_str(str_to_check: str) -> str:
            return 'nextcloud' if 'nextcloud' in str_to_check else str_to_check

        def thunderbird_str(str_to_check: str) -> str:
            return 'thunderbird' if 'thunderbird' in str_to_check else str_to_check

        def curl_str(str_to_check: str) -> str:
            kw_list = [
                'curl',
                'libcurl',
            ]
            for kw in kw_list:
                if kw in str_to_check:
                    return 'curl'
            return str_to_check

        # список из этих функций, чтобы было удобнее итерироваться
        filter_funcs = [
            kernel_str,
            firefox_str,
            systemd_str,
            nextcloud_str,
            thunderbird_str,
            curl_str,
        ]

        limit = 100
        # для того, чтобы пройти все страницы с найденными темами потребуется счетчик для оффсета
        cnt = 0
        result = []
        while True:
            url = f"{REDMINE_URL}/projects/cve/search.xml?&issues=1&" \
                  f"limit={limit}&offset={cnt}&titles_only=1&q=уязвимост"
            resp = self.get_response(url,
                                     bs=True,
                                     parser='xml',
                                     headers=HEADERS,
                                     auth=(credentials['REDMINE_USER'],
                                           credentials['REDMINE_PASSWORD'])
                                     )
            titles = resp.find_all("title")
            t_count = len(titles)
            result.extend(list(map(title_strip, titles)))
            result = list(filter(lambda x: x is not None, result))
            for func in filter_funcs:
                result = list(map(func, result))
            cnt += limit
            if t_count < limit:
                break

        for item in Counter(result).most_common(n):
            print(f"{item[0]:<20} {item[1]:>5}")

    @staticmethod
    def user_wants_create_issue() -> bool:
        """
        Проверяем, хочет ли юзер создавать задачу на трекере
        """
        while True:
            human_resp = input("Создать тему в трекере? ")
            if human_resp.lower() not in ['yes', 'y', 'n', 'no']:
                continue
            return True if human_resp in ['yes', 'y'] else False

    def get_dates(self):
        """
        возвращает кортеж строк с датами требуемого формата,
        для последующего использования в запросе api nist.gov
        """
        to_date = f'{date.today().strftime("%Y-%m-%d")}T23:59:59.999-05:00'
        from_date = f'{(date.today() - timedelta(days=self.days_to_check)).strftime("%Y-%m-%d")}T00:00:00.000-05:00'
        return from_date, to_date

    @staticmethod
    def prepare_url(url, queries: dict) -> str:
        """
        собирает ссылку с требуемыми запросами
        """
        url += '?'
        for k, v in queries.items():
            url += f'{k}={v}' if v else k
            url += '&'
        return url[:-1]

    @staticmethod
    def process_urls(urls: list) -> list:
        """
        Ищем ссылки нужного нам вида.
        * https://github.com/torvalds/linux/commit/**commit** - переделывать не надо
        * git.kernel.org - вырезаем хэш коммита и превращаем в ссылку предыдущего вида
        * остальные ссылки не меняем
        """
        result = []
        for link in urls:
            netloc = parse.urlparse(link).netloc
            path = parse.urlparse(link).path
            if netloc == 'git.kernel.org' or (netloc == 'github.com' and path.split('/')[1] == 'torvalds'):
                result.append(f'https://github.com/torvalds/linux/commit/{link.split("/")[-1].split("=")[-1]}')
            else:
                result.append(link)
        # Уберем возможные дубликаты
        result = list(set(result))
        return result

    def get_rpm_path(self, rpm_name, tag_name):
        """
        Возвращает путь до физического расположения пакета на стапеле
        :param tag_name: тег, в котором ищем пакет
        :param rpm_name: Имя пакета
        :return: Путь до файла в случае успеха, None в противном случае
        """
        package = self.pkg_handler.get_latest_rpm_data(rpm_name, tag_name)
        if not package:
            return

        src_path = f"{REPO_PATH}/{package['name']}/{package['version']}/{package['release']}" \
                   f"/src/{package['nvr']}.src.rpm"
        return src_path

    def get_kern_patches(self, url: str) -> dict:
        """
        Парсим патч по ссылке, в случае, если ссылка формата
        https://github.com/torvalds/linux/commit/**commit**
        """
        netloc = parse.urlparse(url).netloc
        path = parse.urlparse(url).path
        if not (netloc == 'github.com' and path.split('/')[1] == 'torvalds'):
            return {}

        # Получим response
        new_url = f'{url}.patch'
        patch_resp = self.get_response(new_url, bs=True, headers=HEADERS)
        # sanity check
        if not patch_resp:
            return {}
        patch_txt = patch_resp.find('p').text

        date_re = re.compile(r"Date:\s(.+)")
        fixes_re = re.compile(r"Fixes:\s([a-z0-9]+)")
        subject_re = re.compile(r"Subject:\s(.+)")
        files_raw = re.findall(r"(?<=\s-{3}\s)[\S\s]*?(?=diff)", patch_txt)[0].strip().split('\n')

        return {
            'date': date_re.search(patch_txt).group(1) if date_re.search(patch_txt) else None,
            'fixes': fixes_re.search(patch_txt).group(1) if fixes_re.search(patch_txt) else None,
            'subject': subject_re.search(patch_txt).group(1) if subject_re.search(patch_txt) else None,
            'files_changed': files_raw[-1],
            'files': [file.split('|')[0].strip() for file in files_raw[:-1]],
            'patch_text': patch_txt,
        }

    def get_vim_data(self, desc):
        """
        Функция получения версии уязвимого вима и запуска пересборки нового, если доступно.
        Пока заготовка
        :param desc: Описание узявимости
        :return:
        """

        vim_ver_re = re.compile(r"\d\.\d\.\d+")
        vuln_ver = re.findall(vim_ver_re, desc)[0]
        vim_resp = self.get_response("https://github.com/vim/vim/tags", bs=False)
        vim_source_latest = re.findall(r"archive/refs/tags/[^/]+\.tar\.gz", vim_resp.text)[0]
        latest_vim_ver = re.findall(vim_ver_re, vim_source_latest)[0]
        print(f"https://github.com/vim/vim/{vim_source_latest}")

        if compare_versions(vuln_ver, latest_vim_ver):
            return

        # if parse_version(self.vim_73) > parse_version(vuln_ver):
        # TODO выведем сообщение что у нас версия vim не подверженая уязвимости
        # return

        # print(self.get_rpm_path('vim', self.kojitag73))

    def get_issue(self, name, cve, desc, links, check_patch=True) -> dict:
        """
        Разбираем nist json на нужный нам словарь
        :param name: имя пакета, по которому мы потом будем сортировать уязвимости
        :param cve: json с уязвимостью
        :param desc: вытащеное из него описание
        :param links: обработаные URL'ы
        :param check_patch: Будем вытаскивать патчи. Работает для ядра
        :return: словарь с разобраным добром
        """
        patch, scores = [], {}

        if check_patch:
            for link in links:
                patch_resp = self.get_kern_patches(link)
                if patch_resp:
                    patch.append(patch_resp)

        for key in cve['cve']['metrics'].keys():
            scores[cve['cve']['metrics'][key][0]['cvssData']['version']] = \
                cve['cve']['metrics'][key][0]['cvssData']['baseScore']

        return {
            'id': cve['cve']['id'],
            'name': name,
            'description': desc,
            'published': cve['cve']['published'],
            'lastModified': cve['cve']['lastModified'],
            'status': cve['cve']['vulnStatus'],
            'links': links,
            'scores': scores,
            'patch': patch,
        }

    def get_one_cve(self, cve_id: str, check_patch=False) -> dict:
        """
        Номер в виде CVE-2023-1234 на входе, словарь с данными на выходе
        """
        params = {
            NIST_CVE: cve_id,
        }
        url = self.prepare_url(NIST_API_URL, params)
        nist_resp = self.get_response(url, bs=False, headers=HEADERS)
        nist_json = nist_resp.json() if nist_resp else None
        if not nist_json or not nist_json.get('vulnerabilities', ""):
            return {}

        cve = nist_json.get('vulnerabilities')[0]
        desc = cve['cve']['descriptions'][0]['value'].lower()
        links = self.process_urls([link['url'] for link in cve['cve']['references']])

        return self.get_issue('unknown', cve, desc, links, check_patch=check_patch)

    def check_cve(self,
                  pkg_name,
                  check_func,
                  cve,
                  desc,
                  links,
                  cve_data_list,
                  cve_id_list,
                  cve_count,
                  exists_count
                  ):
        """
        Фильтруем уязвимости на нужные/ненужные
        :param pkg_name: Имя пакета, на который проверяем
        :param check_func: Функция, которая проверяет на принадлекжность к пакету
        :param cve: Словарь с данными по уязвимости
        :param desc: слегка обработанное описание уязвимости
        :param links: обработанные (в случае ядра) ссылки предоставленные nist'om
        :param cve_data_list: общий список данных по отфильтрованным уязвимостям
        :param cve_id_list: общий список id отфильтрованных уязвимостей
        :param cve_count: счетчик релевантных уязвимостей
        :param exists_count: счетчик уже существующих на трекере уязвимостей
        :return: Возвращаем счетчики уязвимостей обратно
        """

        is_pkg = check_func(desc, links)
        if is_pkg == IsXIssue.YES:
            cve_count += 1
            cve_id_list.append(cve['cve']['id'])
            # Проверим, заведена ли уже задача по данной CVE
            if CHECK_REDMINE and self.is_cve_exists_rest_api(cve['cve']['id']):
                exists_count += 1
                return cve_count, exists_count
            cve_data_list.append(self.get_issue(pkg_name, cve, desc, links))
            return cve_count, exists_count

        elif is_pkg == IsXIssue.MAYBE:
            self.manual_check.append(cve['cve']['id'])

        return cve_count, exists_count

    def get_current_cves(self, date_from: str, date_to: str) -> list:
        """
        Соберем все cve между датами.
        Формат даты:
        date1 = '2023-03-01T00:00:00.000-05:00'
        date2 = '2023-03-02T23:59:59.999-05:00'
        """
        cve_data_list, cve_id_list = [], []
        exists_count = 0

        # Получим response
        params = {
            NIST_REJ: None,
            NIST_START: date_from,
            NIST_END: date_to
        }
        url = self.prepare_url(NIST_API_URL, params)
        nist_resp = self.get_response(url, bs=False, headers=HEADERS)

        nist_json = nist_resp.json() if nist_resp else None
        if not nist_json or not nist_json.get('vulnerabilities', ""):
            return []

        total_res = nist_json['totalResults']
        print(f'Total CVE found:          {total_res}')
        for cve in nist_json.get('vulnerabilities'):

            # подготовим данные для проверки
            desc = cve['cve']['descriptions'][0]['value'].lower()
            links = self.process_urls([link['url'] for link in cve['cve']['references']])

            for pkg_name, pkg_data in self.pkg_handler.pkgs_data.items():
                pkg_data['cve_counter'], exists_count = self.check_cve(pkg_name,
                                                                       pkg_data['check_func'],
                                                                       cve,
                                                                       desc,
                                                                       links,
                                                                       cve_data_list,
                                                                       cve_id_list,
                                                                       pkg_data['cve_counter'],
                                                                       exists_count)

        moz_cves = self.get_mozilla_cves(n=1)
        for moz_advisories in moz_cves:
            for cve in moz_advisories['cves']:
                if CHECK_REDMINE and not self.is_cve_exists_rest_api(cve['id']):
                    cve_data_list.append(cve)
                    cve_id_list.append(cve['id'])
                    self.pkg_handler.pkgs_data[cve['name']]['cve_counter'] += 1

        print('-' * 80)
        print(f"CVE for {len(self.pkg_handler.pkgs_data)} packages")
        print('-' * 80)
        for pkg_name, pkg_data in self.pkg_handler.pkgs_data.items():
            # классная арифметическая конструкция - для вычисления пробелов
            print(f"{pkg_name}:" + " " * (30 - (len(pkg_name) + 5)) + f"{pkg_data['cve_counter']}")
        print('-' * 80)
        print(f"CVE list:                 {cve_id_list[0] if cve_id_list else ''}")
        if cve_id_list and len(cve_id_list) > 1:
            for item in cve_id_list[1:]:
                print(f"{26 * ' '}{item}")
        print(f"Manual check:             {self.manual_check[0] if self.manual_check else ''}")
        if self.manual_check and len(self.manual_check) > 1:
            for item in self.manual_check[1:]:
                print(f"{26 * ' '}{item}")
        print(f"CVE existed on a tracker: {exists_count}")
        return cve_data_list

    @staticmethod
    def get_issue_str(cve: dict) -> str:
        """
        Формирует строку для последующего создания темы на трекере
        """
        result = ""
        result += f"*Уязвимость {cve['id']}*\n\n"
        result += f"Описание:\n"
        result += f"{cve['description']}\n\n"
        if cve.get('scores', ""):
            result += f'Важность:\n'
            for k, v in cve['scores'].items():
                result += f"* *CVSS {k}: {v}*\n"
        elif cve.get('impact', ""):
            result += f'Важность:\n'
            result += f"* *{cve['impact']}*\n\n"
        if cve.get('fixed_in', ""):
            result += f'Исправлено:\n'
            result += f"* *{cve['fixed_in']}*\n"
        if cve.get('patch', ""):
            for i, item in enumerate(cve['patch'], start=1):
                result += f'\nДанные патча №{i}:\n\n'
                result += f"* Дата: {item['date']}\n"
                if item['fixes']:
                    result += f"* Уязвимый коммит: https://github.com/torvalds/linux/commit/" \
                              f"{item['fixes']}\n"
                result += f"* Тема: {item['subject']}\n"
                result += f"* Изменения: {item['files_changed']}\n"
                result += f"\nФайл(ы):\n\n"
                for filename in item['files']:
                    result += f"* *{filename}*\n"
        result += f"\nСсылки:\n\n"
        for link in cve['links']:
            result += f"* {link}\n"
        if cve.get('source', ""):
            result += f"\nИсточник:\n\n"
            result += f"* {cve['source']}\n\n"
        else:
            result += f"\nИсточник:\n\n"
            result += f"* https://nvd.nist.gov/vuln/detail/{cve['id']}\n\n"
        result += "---\n\n"
        return result

    def create_an_issue(self,
                        subject,
                        desc: str,
                        assigned_id=23,
                        watcher_ids=None,
                        tag=None,
                        ):
        """
        Создает тему на трекере.
        :param subject: Тема задачи
        :param desc: Описание
        :param assigned_id: кому назначена
        :param watcher_ids: Кто наблюдатель
        :param tag: тег
        :return: id задачи
        """
        # if watcher_ids is None:
        #     watcher_ids = [490]
        issue = self.redmine.issue.create(
            project_id=297,  # 297 Уязвимости
            subject=subject,  # заголовок
            tracker_id=10,  # 10 - класс "Задача"
            description=desc,  # тело задачи
            status_id=1,  # 1 - новая
            fixed_version_id=146,  # 146 - Версия: РЕД ОС - РЕД ОС 7.3
            priority_id=1,  # 1 - нормальный приоритет
            assigned_to_id=assigned_id,
            watcher_user_ids=watcher_ids,  # 490 - Чернышев Артем, 25 - Шапошников Олег
            custom_fields=[{'id': 151, 'value': 'Все'},  # Конфигурация ОС: Все
                           {'id': 133, 'value': ['143', '144']},  # 143, 144 - Редакция: Сертифицированная, Стандартная
                           ],
            tag_list=[
                tag  # Метка: например kernel
            ],
        )
        return issue.id

    @staticmethod
    def apply_patches(src_path, patch_path) -> PatchResult:
        """
        Пытаемся применить патч к требуемому дереву сорцов.
        """

        ps = subprocess.Popen(f"patch -p 1 --dry-run < {patch_path}",
                              shell=True,
                              cwd=src_path,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        git_status = ps.communicate()[0].decode('utf-8')
        if 'FAILED' in git_status:
            return PatchResult.FAILED
        elif 'previously applied' in git_status:
            return PatchResult.ALREADY_APPLIED
        elif "can't find file" in git_status:
            return PatchResult.NO_FILE
        else:
            return PatchResult.SUCCESS

    def prepare_issue(self, cve_list, pkg_name, check_patch=False):
        """
        Подготавливаем строки для создания задачи в трекере либо для печати в stdout
        :param cve_list: список подготовленных словарей
        :param pkg_name: имя пакета, для которого собраны уязвимости
        :param check_patch: флаг, что мы хотим проверять патчи. Пока только для ядра
        :return: возвращаем строку, список найденых патчей и удачных применений патчей
        """
        issues = ""
        patches_found = 0
        successful_patches_list = []

        for single_cve in cve_list:
            issues += self.get_issue_str(single_cve)

            if not single_cve.get('patch', "") and not check_patch:
                continue
            patches_found += 1
            for i, patch in enumerate(single_cve['patch'], start=1):
                patch_path = f"{TMP_PATCHES_PATH}/000{i}_{single_cve['id']}.patch"
                with open(patch_path, "w") as f:
                    f.write(patch['patch_text'])
                # Пробуем применить патч к разным версиям ядра
                if CHECK_PATCH:
                    issues += f"Актуальность патча №{i}:\n\n"

                    for kern_path in set(self.kernel_paths):
                        current_ver = re.findall(r"linux-(\d\.\d+\.\d+)", kern_path)[0]
                        patching_result = self.apply_patches(kern_path, patch_path)
                        issues += f"Для версии {current_ver}:\n"

                        if patching_result == PatchResult.FAILED:
                            issues += "* Не удалось применить\n\n"
                        elif patching_result == PatchResult.ALREADY_APPLIED:
                            issues += "* Уже применен\n\n"
                        elif patching_result == PatchResult.NO_FILE:
                            issues += "* Нет файла для применения\n\n"
                        elif patching_result == PatchResult.SUCCESS:
                            issues += "* Применен успешно\n\n"
                            successful_patches_list.append((patch_path,
                                                            single_cve['id'],
                                                            current_ver))

            issues += "---\n\n"

        if issues:
            for tag, pkg_data in zip(self.pkg_handler.tags, self.pkg_handler.pkgs_data[pkg_name]['nvr_list']):
                issues += f"Версия пакета для {tag['name']}: " \
                          f"{self.pkg_handler.pkgs_data[pkg_name]['stapel_name']}-{pkg_data}\n"

        return issues, patches_found, successful_patches_list

    @staticmethod
    def send_to_telegram(message: str) -> dict:
        """
        Послать строку в телеграм
        :param message: строка, которую посылаем
        :return: Возвращает ответ от телеги в случае успеха
        """
        group_id = credentials['TELEGRAM_GROUP_ID']
        bot_token = credentials['BOT_TOKEN']
        send_command = f"curl -s --data 'text={message}' --data 'chat_id={group_id}' " \
                       f"'https://api.telegram.org/bot'{bot_token}'/sendMessage'"
        ps = subprocess.Popen(send_command,
                              shell=True,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        result = ps.communicate()[0].decode('utf-8')
        return json.loads(result) if result else {}

    def check_and_post(self,
                       pkg_name,
                       all_cves,
                       check_patch: bool,
                       assigned_id=23,  # 23 - Владимир Чиркин
                       watcher_ids=None,
                       ):
        """
        Подготавливаем к печати/публикованию уязвимости, собранные на предыдущем этапе.
        Разделяем по пакетам: ядро, вим и т.д.
        :param pkg_name: Имя пакета
        :param all_cves: Полный список отобранных cve
        :param check_patch: Проверяли патчи или нет
        :param assigned_id: Кому назначено
        :param watcher_ids: Кто наблюдатели (в виде list'a)
        :return:
        """

        pkg_cves = list(filter(lambda x: x['name'] == pkg_name, all_cves))
        issues, patches_found, successful_patches_list = self.prepare_issue(pkg_cves,
                                                                            pkg_name,
                                                                            check_patch=check_patch)
        if check_patch:
            print(f"{pkg_name} patches found:     {patches_found}\n")
        if issues:
            print(issues)
        if not (CREATE_AN_ISSUE and pkg_cves and self.redmine):
            return
        if not self.auto and not self.user_wants_create_issue():
            return

        is_kernel = pkg_name == 'kernel'
        if is_kernel:
            subject = 'Множественные уязвимости в ядре Linux' \
                if (len(pkg_cves) > 1) else 'Уязвимость в ядре Linux'
            issue_id = self.create_an_issue(subject=subject,
                                            desc=issues,
                                            assigned_id=assigned_id,
                                            watcher_ids=watcher_ids,
                                            tag=pkg_name)
        else:
            subject = f'Множественные уязвимости в {pkg_name.capitalize()}' \
                if (len(pkg_cves) > 1) else f'Уязвимость в {pkg_name.capitalize()}'
            issue_id = self.create_an_issue(subject=subject,
                                            desc=issues,
                                            assigned_id=assigned_id,
                                            watcher_ids=watcher_ids
                                            )

        if is_kernel and check_patch and successful_patches_list:
            for i, item in enumerate(successful_patches_list):
                dest_patch = f"{DEST_PATCH_PATH}/patches-{item[2]}/" \
                             f"000{i}_kernel-lt-{item[2]}_{item[1]}_{issue_id}.patch"
                Path(item[0]).rename(dest_patch)
                print(f"Patch created: {dest_patch}")

        print(f"Создана задача № {issue_id}")
        issue_url = f"{REDMINE_URL}/issues/{issue_id}"
        print(issue_url)

        if SEND_TO_TELEGRAM:
            self.send_to_telegram(f"Manual check:"
                                  f" {', '.join(self.manual_check)}\nTracker URL: {issue_url}")

    def run(self):
        """
        Основной цикл
        """
        all_cves = self.get_current_cves(*self.get_dates())
        for pkg_name, pkg_data in self.pkg_handler.pkgs_data.items():
            self.check_and_post(pkg_name,
                                all_cves,
                                check_patch=pkg_data['check_patch'],
                                assigned_id=pkg_data['assigned_to'],
                                watcher_ids=pkg_data['watchers'])

    def __del__(self):
        if os.path.exists(TMP_PATCHES_PATH):
            shutil.rmtree(TMP_PATCHES_PATH, ignore_errors=False, onerror=None)


def parse_args():
    parser = argparse.ArgumentParser(
        description="Скрипт для парсинга Linux Kernel CVE, поиска патчей и создания темы на трекере")

    parser.add_argument(
        '-d',
        '--day',
        type=int,
        default=1,
        help="Количество дней за которые смотрим уязвимости. Считаем от текущего"
    )
    parser.add_argument(
        '--cve',
        type=str,
        help="Вывести в консоль данные по конкретной CVE"
    )
    parser.add_argument(
        '--exists',
        action='store_true',
        help="Проверяем, есть ли такая тема на трекере. В случае если не проверяем, "
             "тема создаваться не будет."
    )
    parser.add_argument(
        '--no-exists',
        dest='exists',
        action='store_false',
    )
    parser.add_argument(
        '--patch-check',
        action='store_true',
        help="Проверять патч на локальных сорцах ядра требуемой версии"
    )
    parser.add_argument(
        '--no-patch-check',
        dest='patch_check',
        action='store_false',
    )
    parser.add_argument(
        '--auto',
        action='store_true',
        help="Автоматическое создание темы или спрашиваем у юзера"
    )
    parser.add_argument(
        '--no-auto',
        dest='auto',
        action='store_false',
    )
    parser.add_argument(
        '--send',
        action='store_true',
        help="Посылаем тему в телегу или нет."
    )
    parser.add_argument(
        '--no-send',
        dest='send',
        action='store_false',
    )
    parser.add_argument(
        '--tracker',
        action='store_true',
        help="Создаем тему или нет."
    )
    parser.add_argument(
        '--no-tracker',
        dest='tracker',
        action='store_false',
    )
    parser.add_argument(
        '--stat',
        action='store_true',
        help="Статистика по уязвимостям на трекере"
    )
    parser.add_argument(
        '--users',
        action='store_true',
        help="Создать файл со списком юзеров редмайна"
    )
    parser.add_argument(
        '--zero',
        action='store_true',
        help=""
    )

    parser.set_defaults(exists=True)
    parser.set_defaults(tracker=True)
    parser.set_defaults(auto=True)
    parser.set_defaults(patch_check=True)
    parser.set_defaults(send=True)
    parser.set_defaults(stat=False)
    parser.set_defaults(users=False)
    parser.set_defaults(moz=False)
    parser.set_defaults(zero=False)
    return parser.parse_args()


if __name__ == '__main__':
    arguments = parse_args()
    DAYS_TO_CHECK = arguments.day
    SEND_TO_TELEGRAM = arguments.send
    CHECK_REDMINE = arguments.exists
    CHECK_PATCH = arguments.patch_check
    CREATE_AN_ISSUE = arguments.tracker and CHECK_REDMINE
    AUTO = arguments.auto
    CVE = arguments.cve
    STAT = arguments.stat
    USERS = arguments.users

    cve_checker = CveChecker(DAYS_TO_CHECK, NUMBER_OF_RECON, AUTO)
    if CVE:
        one_cve = cve_checker.get_one_cve(CVE, check_patch=True)
        print(cve_checker.get_issue_str(one_cve))
        exit(0)
    if STAT:
        cve_checker.find_all_issues()
        exit(0)
    if USERS:
        cve_checker.get_users_list()
        exit(0)
    if arguments.zero:
        cve_checker.get_zero_cves()
        exit(0)
    print(80 * "=")
    print(f"Current time:             {datetime.now().strftime('%H:%M:%S %d-%m-%Y')}")
    print(f"Checking CVE's for last:  {DAYS_TO_CHECK} day(s)")
    cve_checker.run()
    print(80 * "=")
