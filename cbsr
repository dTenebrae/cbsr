#!/usr/bin/env python3

import re
import os
import koji
import json
import shutil
import urllib3
import vulners
import requests
import argparse
import subprocess
import redminelib
from enum import Enum
# from io import BytesIO
from time import sleep
from pathlib import Path
import urllib.parse as parse
from bs4 import BeautifulSoup
from redminelib import Redmine
from dotenv import dotenv_values
from datetime import timedelta, date

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ############################ КОНСТАНТЫ #############################
NUMBER_OF_RECON = 5

OS72_TAG = "os72-updates"
OS73_TAG = "os73-updates"
KOJI_URL = "http://10.81.1.26/kojihub"

NIST_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
NIST_CVE = "cveId"
NIST_REJ = "noRejected"
NIST_START = "pubStartDate"
NIST_END = "pubEndDate"

P_FAILED = -1
P_APPLIED = -2
P_NOFILE = -3
P_SUCCESS = 0

# TODO поменять, так как привязано к моей машине
KERNEL_PATH = "/home/tenebrae/devel/tracker/kernel/src"
DEST_PATCH_PATH = "/home/tenebrae/devel/tracker/kernel/patches"
DEST_ISSUE_PATH = "/home/tenebrae/devel/tracker/kernel/issues/current"

TMP_PATCHES_PATH = f"{os.getcwd()}/output/patches"
TMP_ISSUES_PATH = f"{os.getcwd()}/output/issues"

# Явки/пароли для трекера
credentials = dotenv_values(".env")
REDMINE_URL = "https://tracker.red-soft.ru"

HEADERS = {
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,'
              'application/signed-exchange;v=b3;q=0.9',
    'Accept-Language': 'en-US,en;q=0.9,ru;q=0.8',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) '
                  'Chrome/102.0.5005.167 Safari/537.36',
}


# ######################################################################
class PatchResult(Enum):
    FAILED = 1
    ALREADY_APPLIED = 2
    NO_FILE = 3
    SUCCESS = 4


class IsKernel(Enum):
    NO = 1
    MAYBE = 2
    YES = 3


class CveChecker:
    @staticmethod
    def __get_kernel():
        """
        Получаем версии ядра для требуемых тегов.
        """
        package_basename = "kernel-lt"
        session = koji.ClientSession(KOJI_URL)
        kojitag72 = session.getTag(OS72_TAG)
        kojitag73 = session.getTag(OS73_TAG)

        # Задел на будущее, список пакетов, с которым можно сравнивать упоминаемый в CVE
        # TODO Сделать универсальный парсер
        # os72_packages = session.getLatestBuilds(OS72_TAG)
        # os73_packages = session.getLatestBuilds(OS73_TAG)

        package_list_72 = session.getLatestRPMS(kojitag72['id'], arch='src', package=package_basename)[1]
        package_list_73 = session.getLatestRPMS(kojitag73['id'], arch='src', package=package_basename)[1]
        package72 = package_list_72[0]['version'] if package_list_72 else None
        package73 = package_list_73[0]['version'] if package_list_73 else None
        return package72, package73

    @staticmethod
    def __redmine_auth():
        """
        Простой wrapper для авторизации
        """
        redmine = Redmine(REDMINE_URL,
                          username=credentials['REDMINE_USER'],
                          password=credentials['REDMINE_PASSWORD'])
        try:
            redmine.auth()
            return redmine
        except redminelib.exceptions.AuthError:
            print("Auth Failed")
            return None

    @staticmethod
    def __vulners_auth():
        vulners_api = vulners.VulnersApi(api_key=credentials['VULNERS_KEY'])
        return vulners_api

    @staticmethod
    def __prepare_dirs():
        """
        Проверяем на существование требуемые папки
        """
        if not os.path.exists(KERNEL_PATH):
            global CHECK_PATCH
            CHECK_PATCH = False
            print("No kernel src directory exists")
        if not os.path.exists(DEST_PATCH_PATH):
            os.makedirs(DEST_PATCH_PATH)
        if not os.path.exists(DEST_ISSUE_PATH):
            os.makedirs(DEST_ISSUE_PATH)

        if os.path.exists(TMP_PATCHES_PATH):
            shutil.rmtree(TMP_PATCHES_PATH, ignore_errors=False, onerror=None)
        if os.path.exists(TMP_ISSUES_PATH):
            shutil.rmtree(TMP_ISSUES_PATH, ignore_errors=False, onerror=None)
        os.makedirs(TMP_PATCHES_PATH)
        os.makedirs(TMP_ISSUES_PATH)

    def __init__(self, days_to_check, recon_num):
        self.__prepare_dirs()
        self.kernel_72, self.kernel_73 = self.__get_kernel()
        self.kernel_72_path, self.kernel_73_path = f"{KERNEL_PATH}/linux-{self.kernel_72}", \
                                                   f"{KERNEL_PATH}/linux-{self.kernel_73}"
        self.days_to_check = days_to_check
        self.recon_num = recon_num
        self.redmine = self.__redmine_auth()
        self.vulners = self.__vulners_auth()
        self.manual_check = []

    @staticmethod
    def __get_respone(*args, bs=True, parser='lxml', **kwargs):
        """
        Получим ответ по url
        * bs - вернуть как soup или обычные response
        * parser - какой парсер страницы используем (html, xml, lxml)
        * NUMBER_OF_RECON - глобальная опция. Сколько стучимся, если поймали ошибку соединения
        """
        recon_count = 0
        while recon_count <= NUMBER_OF_RECON:
            try:
                response: requests.Response = requests.get(*args, **kwargs)
                # проверим код ответа
                if response.status_code != requests.codes.ok:
                    raise ConnectionError
                sleep(0.1)
                if bs:
                    return BeautifulSoup(response.text, parser)
                else:
                    return response
            except ConnectionError:
                # Стучимся пока не соединимся.
                sleep(0.250)
                recon_count += 1
        print(f'Ошибка соединения')

    def is_cve_exists_rest_api(self, cve: str) -> bool:
        """
        Костыльная проверка на существование CVE в трекере.
        Используется, пока не разберусь с оберткой redminelib
        """
        url = f"{REDMINE_URL}/projects/cve/search.xml?&issues=1&q={cve}"
        # Так как редмайн ищет все вхождения подстроки, мы можем
        # проигнорировать CVE сами того не желая.
        # Например: CVE-2023-1281 при наличии на трекере CVE-2023-12811
        # посчитается как существующая
        exact_search_re = re.compile(fr"\b{cve}\b", re.I)

        resp = self.__get_respone(url,
                                  bs=True,
                                  parser='xml',
                                  headers=HEADERS,
                                  auth=(credentials['REDMINE_USER'], credentials['REDMINE_PASSWORD'])
                                  )
        # Найдем, сколько раз CVE встречается в поиске
        f_count = resp.find("results").get("total_count")
        try:
            result = int(f_count)
            if result:
                return bool(exact_search_re.findall(resp.find("description").text))
            return False
        except ValueError:
            print("Ошибка поиска")
            return False

    @staticmethod
    def __user_wants_create_issue() -> bool:
        """
        Проверяем, хочет ли юзер создавать задачу на трекере
        """
        while True:
            human_resp = input("Создать тему в трекере? ")
            if human_resp.lower() not in ['yes', 'y', 'n', 'no']:
                continue
            return True if human_resp in ['yes', 'y'] else False

    def __get_dates(self):
        """
        возвращает кортеж строк с датами требуемого формата,
        для последующего использования в запросе api nist.gov
        """
        to_date = f'{date.today().strftime("%Y-%m-%d")}T23:59:59.999-05:00'
        from_date = f'{(date.today() - timedelta(days=self.days_to_check)).strftime("%Y-%m-%d")}T00:00:00.000-05:00'
        return from_date, to_date

    @staticmethod
    def __prepare_url(url, queries: dict) -> str:
        """
        собирает ссылку с требуемыми запросами
        """
        url += '?'
        for k, v in queries.items():
            url += f'{k}={v}' if v else k
            url += '&'
        return url[:-1]

    @staticmethod
    def process_urls(urls: list) -> list:
        """
        Ищем ссылки нужного нам вида.
        * https://github.com/torvalds/linux/commit/**commit** - переделывать не надо
        * git.kernel.org - вырезаем хэш коммита и превращаем в ссылку предыдущего вида
        * остальные ссылки не меняем
        """
        result = []
        for link in urls:
            netloc = parse.urlparse(link).netloc
            path = parse.urlparse(link).path
            if netloc == 'git.kernel.org' or (netloc == 'github.com' and path.split('/')[1] == 'torvalds'):
                result.append(f'https://github.com/torvalds/linux/commit/{link.split("/")[-1].split("=")[-1]}')
            else:
                result.append(link)
        # Уберем возможные дубликаты
        result = list(set(result))
        return result

    def __get_patches(self, url: str) -> dict:
        """
        Парсим патч по ссылке, в случае, если ссылка формата
        https://github.com/torvalds/linux/commit/**commit**
        """
        netloc = parse.urlparse(url).netloc
        path = parse.urlparse(url).path
        if not (netloc == 'github.com' and path.split('/')[1] == 'torvalds'):
            return {}

        # Получим response
        new_url = f'{url}.patch'
        patch_resp = self.__get_respone(new_url, bs=True, headers=HEADERS)
        # sanity check
        if not patch_resp:
            return {}
        patch_txt = patch_resp.find('p').text

        date_re = re.compile(r"Date:\s(.+)")
        fixes_re = re.compile(r"Fixes:\s([a-z0-9]+)")
        subject_re = re.compile(r"Subject:\s(.+)")
        files_raw = re.findall(r"(?<=---)[\S\s]*?(?=diff)", patch_txt)[0].strip().split('\n')

        return {
            'date': date_re.search(patch_txt).group(1) if date_re.search(patch_txt) else None,
            'fixes': fixes_re.search(patch_txt).group(1) if fixes_re.search(patch_txt) else None,
            'subject': subject_re.search(patch_txt).group(1) if subject_re.search(patch_txt) else None,
            'files_changed': files_raw[-1],
            'files': [file.split('|')[0].strip() for file in files_raw[:-1]],
            'patch_text': patch_txt,
        }

    @staticmethod
    def is_kernel_issue(desc, links) -> IsKernel:
        """
        Проверка на то, что уязвимость относится к ядреной
        """
        desc = desc.lower()

        kernel_urls = [
            'lore.kernel.org',
            'git.kernel.org',
            'lkml.org',
            'bugzilla.redhat.com',
            'bugzilla.suse.com',
            'cdn.kernel.org',
            'lkml.kernel.org',
            'kernel.dance',
            'lists.debian.org',
            'www.debian.org',
            'www.spinics.net',
        ]

        if ('linux' not in desc) or ('android linux kernel' in desc):
            return IsKernel.NO

        for link in links:
            netloc = parse.urlparse(link).netloc
            path_first = parse.urlparse(link).path.split('/')[1]
            if (netloc == 'github.com' and path_first == 'torvalds') or (netloc in kernel_urls):
                return IsKernel.YES

        if 'linux kernel' in desc:
            return IsKernel.MAYBE

        return IsKernel.NO

    def get_current_cves(self, date_from: str, date_to: str) -> list:
        """
        Соберем все cve между датами.
        Формат даты:
        date1 = '2023-03-01T00:00:00.000-05:00'
        date2 = '2023-03-02T23:59:59.999-05:00'
        """
        cve_list, cve_id_list = [], []
        kernel_cve_count, exists_count = 0, 0

        # Получим response
        params = {
            NIST_REJ: None,
            NIST_START: date_from,
            NIST_END: date_to
        }
        url = self.__prepare_url(NIST_API_URL, params)
        nist_resp = self.__get_respone(url, bs=False, headers=HEADERS)

        nist_json = nist_resp.json() if nist_resp else None
        if not nist_json or not nist_json.get('vulnerabilities', ""):
            return []

        total_res = nist_json['totalResults']
        print(f'Total CVE found: {total_res}')
        for cve in nist_json.get('vulnerabilities'):
            patch, scores = [], {}
            cve_id = cve['cve']['id']
            desc = cve['cve']['descriptions'][0]['value']
            links = self.process_urls([link['url'] for link in cve['cve']['references']])

            # TODO сделать для всех видов пакетов
            check_result = self.is_kernel_issue(desc, links)
            if check_result == IsKernel.NO:
                continue
            elif check_result == IsKernel.MAYBE:
                self.manual_check.append(cve_id)
                continue

            kernel_cve_count += 1
            cve_id_list.append(cve_id)
            # Проверим, заведена ли уже задача по данной CVE
            if CHECK_REDMINE and self.is_cve_exists_rest_api(cve_id):
                exists_count += 1
                continue

            for link in links:
                patch_resp = self.__get_patches(link)
                if patch_resp:
                    patch.append(patch_resp)
            for key in cve['cve']['metrics'].keys():
                scores[cve['cve']['metrics'][key][0]['cvssData']['version']] = \
                    cve['cve']['metrics'][key][0]['cvssData']['baseScore']

            result = {
                'id': cve_id,
                'description': desc,
                'published': cve['cve']['published'],
                'lastModified': cve['cve']['lastModified'],
                'status': cve['cve']['vulnStatus'],
                'links': links,
                'scores': scores,
                'ai_scores': self.vulners.get_ai_score(desc)[0],
                'patch': patch,
            }

            cve_list.append(result)
        print(f"Kernel CVE: {kernel_cve_count}")
        print(f"CVE list: {', '.join(cve_id_list)}")
        print(f"Manual check: {', '.join(self.manual_check)}")
        print(f"CVE existed on a tracker: {exists_count}")
        return cve_list

    @staticmethod
    def _get_issue_str(kernel_cve: dict) -> str:
        """
        Формирует строку для последующего создания темы на трекере
        """
        result = ""
        result += f"h5. Уязвимость {kernel_cve['id']}\n\n"
        result += f"Описание:\n"
        result += f"{kernel_cve['description']}\n\n"
        if kernel_cve['scores']:
            result += f'Важность:\n'
            for k, v in kernel_cve['scores'].items():
                result += f"* *CVSS {k}: {v}*\n"
        elif AI_SCORE:
            result += f'Важность:\n'
            result += f"* *AI Score: {kernel_cve['ai_score']}\n"
            result += f"_Оценка - результат работы нейросети, поэтому является ознакомительной_"
        if kernel_cve['patch']:
            for item in kernel_cve['patch']:
                result += f'\nДанные патча:\n\n'
                result += f"* Дата: {item['date']}\n"
                if item['fixes']:
                    result += f"* Уязвимый коммит: https://github.com/torvalds/linux/commit/" \
                              f"{item['fixes']}\n"
                result += f"* Тема: {item['subject']}\n"
                result += f"* Изменения: {item['files_changed']}\n"
                result += f"\nФайл(ы):\n\n"
                for filename in item['files']:
                    result += f"* *{filename}*\n"
        result += f"\nСсылки:\n\n"
        for link in kernel_cve['links']:
            result += f"* {link}\n"
        result += f"\nИсточник:\n\n"
        result += f"* https://nvd.nist.gov/vuln/detail/{kernel_cve['id']}\n\n"
        return result

    def create_an_issue(self,
                        desc: str,
                        # patches: list,
                        multiple=False):
        """
        Создает тему на трекере.
        * desc - Тело задачи
        * patches - список со строками, содержащими текст патчей
        * multiple - Флаг для выбора названия темы
        Возвращает ID темы
        """
        subject = 'Множественные уязвимости в ядре Linux' if multiple else 'Уязвимость в ядре Linux'
        # TODO Сделать рабочее присоединение файлов
        # patch_list = [{'path': BytesIO(patch.encode('utf-8'))} for patch in patches]
        issue = self.redmine.issue.create(
            project_id=297,  # 297 Уязвимости
            subject=subject,  # заголовок
            tracker_id=10,  # 10 - класс "Задача"
            description=desc,  # тело задачи
            status_id=1,  # 1 - новая
            fixed_version_id=146,  # 146 - Версия: РЕД ОС - РЕД ОС 7.3
            priority_id=1,  # 1 - нормальный приоритет
            assigned_to_id=490,
            watcher_user_ids=[490],  # 490 - Чернышев Артем, 25 - Шапошников Олег
            custom_fields=[{'id': 151, 'value': 'Все'},  # Конфигурация ОС: Все
                           {'id': 133, 'value': ['143', '144']},  # 143, 144 - Редакция: Сертифицированная, Стандартная
                           ],
            tag_list=[
                'kernel'  # Метка: kernel
            ],
            # uploads=patch_list,
        )
        return issue.id

    @staticmethod
    def is_src_tree_fine(src_path) -> bool:
        ps = subprocess.Popen("git status",
                              shell=True,
                              cwd=src_path,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        git_status = ps.communicate()[0].decode('utf-8')
        if 'fatal: not a git repository' in git_status:
            print("Not a git repository")
            return False
        elif 'Changes not staged for commit' in git_status:
            print("Some untracked changes in git tree")
            return False
        elif 'Changes to be committed' in git_status:
            print("Not commited files exists in tree")
            return False
        elif 'working tree clean' in git_status:
            return True
        else:
            print("Unknown error")
            return False

    @staticmethod
    def reset_git_tree(src_path):
        subprocess.run(["git", "add", "."],
                       cwd=src_path,
                       stdout=subprocess.DEVNULL)
        subprocess.run(['git', 'commit', '-m', 'tmp'],
                       cwd=src_path,
                       stdout=subprocess.DEVNULL)
        subprocess.run(["git", "reset", "--hard", "HEAD~1"],
                       cwd=src_path,
                       stdout=subprocess.DEVNULL,
                       stderr=subprocess.DEVNULL)

    def apply_patches(self, src_path, patch_path) -> PatchResult:
        """
        Пытаемся применить патч к требуемому дереву сорцов.
        Возвращает:
        0 - успешно пропатчено
        1 - применение патча не удалось
        2 - патч уже присутствет в сорцах
        3 - файла, к которому применяется файл, нет в наличии
        """
        if not self.is_src_tree_fine(src_path):
            print("Trying to reset source tree")
            self.reset_git_tree(src_path)

        ps = subprocess.Popen(f"patch -p 1 --dry-run < {patch_path}",
                              shell=True,
                              cwd=src_path,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        git_status = ps.communicate()[0].decode('utf-8')
        if 'FAILED' in git_status:
            return PatchResult.FAILED
        elif 'previously applied' in git_status:
            return PatchResult.ALREADY_APPLIED
        elif "can't find file" in git_status:
            return PatchResult.NO_FILE
        else:
            return PatchResult.SUCCESS

    @staticmethod
    def send_to_telegram(message: str) -> dict:
        """
        Послать строку в телеграм
        :param message: строка, которую посылаем
        :return: Возвращает ответ от телеги в случае успеха
        """
        group_id = credentials['TELEGRAM_GROUP_ID']
        bot_token = credentials['BOT_TOKEN']
        send_command = f"curl -s --data 'text={message}' --data 'chat_id={group_id}' " \
                       f"'https://api.telegram.org/bot'{bot_token}'/sendMessage'"
        ps = subprocess.Popen(send_command,
                              shell=True,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        result = ps.communicate()[0].decode('utf-8')
        # TODO сделать try-except
        return json.loads(result)

    def run(self):
        """
        Основной цикл
        TODO разбить на функции, а то bloated
        """
        issues = ""
        patch_strs = []
        patches_found = 0
        successful_patches_list = []

        kernel_cves = self.get_current_cves(*self.__get_dates())
        for k_cve in kernel_cves:
            issues += self._get_issue_str(k_cve)
            if not k_cve['patch']:
                continue
            patches_found += 1
            for i, patch in enumerate(k_cve['patch']):
                patch_strs.append(patch['patch_text'])
                patch_path = f"{TMP_PATCHES_PATH}/000{i + 1}_{k_cve['id']}.patch"
                with open(patch_path, "w") as f:
                    f.write(patch['patch_text'])
                # Пробуем применить патч к актуальной версии ядра
                if CHECK_PATCH:
                    patching_result = self.apply_patches(self.kernel_73_path,
                                                         patch_path)
                    issues += "Актуальность патча:\n"
                    if patching_result == PatchResult.FAILED:
                        issues += "* Не удалось применить\n\n"
                    elif patching_result == PatchResult.ALREADY_APPLIED:
                        issues += "* Уже применен\n\n"
                    elif patching_result == PatchResult.NO_FILE:
                        issues += "* Нет файла для применения\n\n"
                    elif patching_result == PatchResult.SUCCESS:
                        issues += "* Применен успешно\n\n"
                        successful_patches_list.append((patch_path, k_cve['id']))

            issues += "---\n\n"

        if issues:
            if self.kernel_72 == self.kernel_73:
                issues += f"\nОценить уязвимость текущей версии ядра {self.kernel_73}\n"
            else:
                issues += f"\nОценить уязвимость ядер версий {self.kernel_72} и {self.kernel_73}\n"
            print(f"Patches found: {patches_found}\n")
            print(issues)

        if CREATE_AN_ISSUE and kernel_cves and self.redmine and self.__user_wants_create_issue():
            issue_id = self.create_an_issue(issues,
                                            # patches=patch_strs,
                                            multiple=(len(kernel_cves) > 1))
            issue_path = f"{TMP_ISSUES_PATH}/issues-{issue_id}.md"
            with open(issue_path, "w") as f:
                f.write(issues)

            Path(issue_path).rename(f"{DEST_ISSUE_PATH}/issues-{issue_id}.md")

            if successful_patches_list:
                for i, item in enumerate(successful_patches_list):
                    Path(item[0]).rename(
                        f"{DEST_PATCH_PATH}/patches-{self.kernel_73}/000{i}_kernel-lt-"
                        f"{self.kernel_73}_{item[1]}_{issue_id}.patch")
                pass
            print(f"Создана задача № {issue_id}")
            issue_url = f"{REDMINE_URL}/issues/{issue_id}"
            print(issue_url)

            if SEND_TO_TELEGRAM:
                self.send_to_telegram(f"Manual check: {', '.join(self.manual_check)}\nTracker URL: {issue_url}")


def parse_args():
    parser = argparse.ArgumentParser(
        description="Скрипт для парсинга Linux Kernel CVE, поиска патчей и создания темы на трекере")

    parser.add_argument(
        '-d',
        '--day',
        type=int,
        default=1,
        help="Количество дней за которые смотрим уязвимости. Считаем от текущего"
    )
    parser.add_argument(
        '--exists',
        action='store_true',
        help="Проверяем, есть ли такая тема на трекере. В случае если не проверяем, "
             "тема создаваться не будет."
    )
    parser.add_argument(
        '--no-exists',
        dest='exists',
        action='store_false',
    )
    parser.add_argument(
        '-n',
        '--neural',
        action='store_true',
        help="Включить приблизительную оценку важности уязвимости с помощью нейросети."
             "Качество не впечатляет"
    )
    parser.add_argument(
        '--patch-check',
        action='store_true',
        help="Проверять патч на локальных сорцах ядра требуемой версии"
    )
    parser.add_argument(
        '--no-patch-check',
        dest='patch_check',
        action='store_false',
    )
    parser.add_argument(
        '--send',
        action='store_true',
        help="Посылаем тему в телегу или нет."
    )
    parser.add_argument(
        '--no-send',
        dest='send',
        action='store_false',
    )
    parser.add_argument(
        '--tracker',
        action='store_true',
        help="Создаем тему или нет."
    )
    parser.add_argument(
        '--no-tracker',
        dest='tracker',
        action='store_false',
    )
    parser.set_defaults(exists=True)
    parser.set_defaults(tracker=True)
    parser.set_defaults(patch_check=True)
    parser.set_defaults(send=True)
    parser.set_defaults(neural=False)
    return parser.parse_args()


if __name__ == '__main__':
    arguments = parse_args()
    DAYS_TO_CHECK = arguments.day
    SEND_TO_TELEGRAM = arguments.send
    CHECK_REDMINE = arguments.exists
    CHECK_PATCH = arguments.patch_check
    CREATE_AN_ISSUE = arguments.tracker and CHECK_REDMINE
    AI_SCORE = arguments.neural

    print(f"Checking CVE's for last: {DAYS_TO_CHECK} day(s)")
    cve_checker = CveChecker(DAYS_TO_CHECK, NUMBER_OF_RECON)
    cve_checker.run()
