#!/home/tenebrae/devel/cbsr/venv/bin/python3

import re
import os
import koji
import json
import shutil
import urllib3
# import vulners
import requests
import argparse
import subprocess
import redminelib
from enum import Enum
from time import sleep
from pathlib import Path
from random import choice
import urllib.parse as parse
from bs4 import BeautifulSoup
from redminelib import Redmine
from collections import Counter
from dotenv import dotenv_values
from urllib.parse import urljoin
from pkg_resources import parse_version
from datetime import timedelta, date, datetime

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
os.chdir("/home/tenebrae/devel/cbsr/")

# ############################ КОНСТАНТЫ #############################
NUMBER_OF_RECON = 5

OS72_TAG = "os72-updates"
OS73_TAG = "os73-updates"
KOJI_URL = "http://10.81.1.26/kojihub"
REPO_PATH = '/mnt/ssd/koji/packages'

NIST_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
NIST_CVE = "cveId"
NIST_REJ = "noRejected"
NIST_START = "pubStartDate"
NIST_END = "pubEndDate"

KERNEL_PATH = f"{os.path.expanduser('.')}/src"
# TODO поменять, так как привязано к моей машине
DEST_PATCH_PATH = "/home/tenebrae/devel/tracker/kernel/patches"
USERS_LIST = f"{os.path.expanduser('.')}/users.json"

TMP_PATCHES_PATH = f"{os.getcwd()}/output/patches"

# Явки/пароли для трекера
credentials = dotenv_values(".env")
REDMINE_URL = "https://tracker.red-soft.ru"

HEADERS = {
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,'
              'application/signed-exchange;v=b3;q=0.9',
    'Accept-Language': 'en-US,en;q=0.9,ru;q=0.8',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) '
                  'Chrome/102.0.5005.167 Safari/537.36',
}


# ######################################################################
class PatchResult(Enum):
    FAILED = 1
    ALREADY_APPLIED = 2
    NO_FILE = 3
    SUCCESS = 4


class IsXIssue(Enum):
    NO = 1
    MAYBE = 2
    YES = 3


class CveChecker:
    def get_latest_rpm_data(self, package_name, tag_name, deep=True):
        """
        На входе получает имя пакета, на выходе отдает dict с информацией по нему
        :param tag_name: Тег, в котором проверяем
        :param package_name: Имя пакета
        :param deep: Флаг, какую логику использовать для поиска последнего пакета.
        В случае False будет брать последней по дате, что может быть не слишком удачным выбором
        :return: dict с инфой по пакету в случае успеха, None в противном случае
        """
        if deep:
            package_list_raw = self.session.listTagged(tag_name['id'], package=package_name)
            # выделим старшую эпоху
            epoch_list = [i['epoch'] for i in package_list_raw if i['epoch']]
            latest_epoch = max(epoch_list) if epoch_list else None
            latest_rpms = list(
                filter(lambda x: x['epoch'] == latest_epoch, package_list_raw)) if latest_epoch else package_list_raw
            # старшую версию
            latest_version = max([i['version'] for i in latest_rpms], key=parse_version)
            latest_rpms = list(filter(lambda x: x['version'] == latest_version, latest_rpms))
            # и старший релиз
            latest_release = max([i['release'].split('.')[0] for i in latest_rpms], key=parse_version)
            package_list = list(filter(lambda x: x['release'].split('.')[0] == latest_release, latest_rpms))
        else:
            package_list = self.session.getLatestRPMS(tag_name['id'], arch='src', package=package_name)[1]

        return package_list[0] if package_list else None

    def __get_package_data(self):
        """
        Получаем версии ядра для требуемых тегов.
        """
        kernel_basename = "kernel-lt"
        vim_basename = 'vim'
        self.kojitag72 = self.session.getTag(OS72_TAG)
        self.kojitag73 = self.session.getTag(OS73_TAG)

        # Задел на будущее, список пакетов, с которым можно сравнивать упоминаемый в CVE
        # TODO Сделать универсальный парсер
        # os72_packages = session.getLatestBuilds(OS72_TAG)
        # os73_packages = session.getLatestBuilds(OS73_TAG)

        self.kernel_72 = self.get_latest_rpm_data(kernel_basename, self.kojitag72)['version']
        self.kernel_73 = self.get_latest_rpm_data(kernel_basename, self.kojitag73)['version']
        self.vim_72 = self.get_latest_rpm_data(vim_basename, self.kojitag72)['version']
        self.vim_73 = self.get_latest_rpm_data(vim_basename, self.kojitag73)['version']

        self.kernel_72_path, self.kernel_73_path = f"{KERNEL_PATH}/linux-{self.kernel_72}", \
            f"{KERNEL_PATH}/linux-{self.kernel_73}"

    @staticmethod
    def __redmine_auth():
        """
        Простой wrapper для авторизации
        """
        redmine = Redmine(REDMINE_URL,
                          username=credentials['REDMINE_USER'],
                          password=credentials['REDMINE_PASSWORD'])
        try:
            redmine.auth()
            return redmine
        except redminelib.exceptions.AuthError:
            print("Auth Failed")
            return None

    # @staticmethod
    # def __vulners_auth():
    #     vulners_api = vulners.VulnersApi(api_key=credentials['VULNERS_KEY'])
    #     return vulners_api

    @staticmethod
    def exec_bash(bash_cmd: str) -> str:
        """
        Простая обертка для выполнения bash-команд
        :param bash_cmd: Команда в строковом формате
        :return: Возвращает результат выполнения в UTF-8 кодировке
        """
        ps = subprocess.Popen(bash_cmd,
                              shell=True,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.DEVNULL)
        return ps.communicate()[0].decode('utf-8')

    def download_kernel_src(self, kern_ver: str):
        """
        Качаем сорцы ядра требуемой версии и распаковываем
        :param kern_ver: версия ядра
        :return:
        """
        # TODO сделать под разные мажорные версии ядер
        kern_src_url = f"https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-{kern_ver}.tar.xz"
        kernel_src_filename = f"{KERNEL_PATH}/linux-{kern_ver}.tar.xz"

        # Качаем архив
        req = self.get_response(kern_src_url, bs=False)
        with open(kernel_src_filename, "wb") as f:
            for chunk in req.iter_content(100000):
                f.write(chunk)

        # Распаковываем в папку и удаляем архив
        unpack_cmd = f"tar xf {kernel_src_filename} -C {KERNEL_PATH}"
        rm_cmd = f"rm -f {kernel_src_filename}"
        self.exec_bash(unpack_cmd)
        self.exec_bash(rm_cmd)

    def __prepare_dirs(self):
        """
        Проверяем на существование требуемые папки
        """
        if not os.path.exists(KERNEL_PATH):
            os.makedirs(KERNEL_PATH)

        if not os.path.exists(USERS_LIST):
            self.get_users_list()

        # если нет сорцов для какой либо версии проверяемых ядер - скачиваем и распаковываем их
        if self.kernel_72 == self.kernel_73:
            if not os.path.exists(f"{KERNEL_PATH}/linux-{self.kernel_73}"):
                print(f"Downloading sources for linux kernel {self.kernel_73}")
                self.download_kernel_src(self.kernel_73)
        else:
            if not os.path.exists(f"{KERNEL_PATH}/linux-{self.kernel_72}"):
                print(f"Downloading sources for linux kernel {self.kernel_72}")
                self.download_kernel_src(self.kernel_72)
            elif not os.path.exists(f"{KERNEL_PATH}/linux-{self.kernel_73}"):
                print(f"Downloading sources for linux kernel {self.kernel_73}")
                self.download_kernel_src(self.kernel_73)

        # if not os.path.exists(DEST_PATCH_PATH):
        #     os.makedirs(DEST_PATCH_PATH)
        # if not os.path.exists(DEST_ISSUE_PATH):
        #     os.makedirs(DEST_ISSUE_PATH)

        if os.path.exists(TMP_PATCHES_PATH):
            shutil.rmtree(TMP_PATCHES_PATH, ignore_errors=False, onerror=None)
        os.makedirs(TMP_PATCHES_PATH)

    def __init__(self, days_to_check, recon_num, auto):

        self.session = koji.ClientSession(KOJI_URL)
        self.__get_package_data()
        self.__prepare_dirs()
        self.redmine = self.__redmine_auth()
        # self.vulners = self.__vulners_auth()

        self.days_to_check = days_to_check
        self.recon_num = recon_num
        self.auto = auto
        self.manual_check = []

        with open(USERS_LIST) as f:
            self.users_dict = json.loads(f.read())

        # TODO в итоге это добро надо выносить в отдельный модуль
        self.pkgs_data = {
            'kernel': {
                'check_func': self.is_kernel_issue,
                'cve_counter': 0,
                'is_kernel': True,  # убрать, потому как ничто не ядро, кроме ядра
                'check_patch': True,
                'assigned_to': int(self.users_dict['artem.chernyshev']),
                'watchers': [int(self.users_dict['artem.chernyshev'])],
            },
            'vim': {
                'check_func': self.is_vim_issue,
                'cve_counter': 0,
                'is_kernel': False,
                'check_patch': False,
                'assigned_to': int(self.users_dict['artem.chernyshev']),
                'watchers': [int(self.users_dict['artem.chernyshev'])],
            },
            'nextcloud': {
                'check_func': self.is_nextcloud_issue,
                'cve_counter': 0,
                'is_kernel': False,
                'check_patch': False,
                'assigned_to': int(self.users_dict['vladislav.mitin']),
                'watchers': None,
            },
            'gpac': {
                'check_func': self.is_gpac_issue,
                'cve_counter': 0,
                'is_kernel': False,
                'check_patch': False,
                'assigned_to': int(self.users_dict['alexey.rodionov']),
                'watchers': None,
            },
            'redis': {
                'check_func': self.is_redis_issue,
                'cve_counter': 0,
                'is_kernel': False,
                'check_patch': False,
                'assigned_to': int(self.users_dict['vladislav.mitin']),
                'watchers': None,
            },
            'systemd': {
                'check_func': self.is_systemd_issue,
                'cve_counter': 0,
                'is_kernel': False,
                'check_patch': False,
                'assigned_to': int(self.users_dict['vladimir.chirkin']),
                'watchers': None,
            },
            'django': {
                'check_func': self.is_django_issue,
                'cve_counter': 0,
                'is_kernel': False,
                'check_patch': False,
                'assigned_to': choice([int(self.users_dict['vitaly.peshcherov']),
                                       int(self.users_dict['ilia.polyvyanyy'])]),
                'watchers': None,
            },
            'moodle': {
                'check_func': self.is_moodle_issue,
                'cve_counter': 0,
                'is_kernel': False,
                'check_patch': False,
                'assigned_to': choice([int(self.users_dict['vladislav.mitin']),
                                       int(self.users_dict['ilia.polyvyanyy'])]),
                'watchers': None,
            },
        }

    @staticmethod
    def get_response(*args, bs=True, parser='lxml', **kwargs):
        """
        Получим ответ по url
        * bs - вернуть как soup или обычные response
        * parser - какой парсер страницы используем (html, xml, lxml)
        * NUMBER_OF_RECON - глобальная опция. Сколько стучимся, если поймали ошибку соединения
        """
        recon_count = 0
        while recon_count <= NUMBER_OF_RECON:
            try:
                response: requests.Response = requests.get(*args, **kwargs)
                # проверим код ответа
                if response.status_code != requests.codes.ok:
                    raise ConnectionError
                sleep(0.1)
                if bs:
                    return BeautifulSoup(response.text, parser)
                else:
                    return response
            except ConnectionError:
                # Стучимся пока не соединимся.
                sleep(0.250)
                recon_count += 1
        print(f'Ошибка соединения')

    def is_cve_exists_rest_api(self, cve: str) -> bool:
        """
        Костыльная проверка на существование CVE в трекере.
        Используется, пока не разберусь с оберткой redminelib
        """
        url = f"{REDMINE_URL}/projects/cve/search.xml?&issues=1&q={cve}"
        # Так как редмайн ищет все вхождения подстроки, мы можем
        # проигнорировать CVE сами того не желая.
        # Например: CVE-2023-1281 при наличии на трекере CVE-2023-12811
        # посчитается как существующая
        exact_search_re = re.compile(fr"\b{cve}\b", re.I)

        resp = self.get_response(url,
                                 bs=True,
                                 parser='xml',
                                 headers=HEADERS,
                                 auth=(credentials['REDMINE_USER'], credentials['REDMINE_PASSWORD'])
                                 )
        # Найдем, сколько раз CVE встречается в поиске
        f_count = resp.find("results").get("total_count")
        try:
            result = int(f_count)
            if result:
                return bool(exact_search_re.findall(resp.find("description").text))
            return False
        except ValueError:
            print("Ошибка поиска")
            return False

    def get_users_list(self):
        """
        создает файл со списком юзеров трекера с их номерами
        :return:
        """
        result = {}
        url = f"{REDMINE_URL}/users?per_page=500"
        resp = self.get_response(url,
                                 bs=True,
                                 parser='xml',
                                 headers=HEADERS,
                                 auth=(credentials['REDMINE_USER'], credentials['REDMINE_PASSWORD'])
                                 )
        for user in resp.find_all('td', attrs={'class': 'login'}):
            user_lnk = user.find('a')
            if user_lnk.text:
                result[user_lnk.text] = int(re.findall(r"\d+", user_lnk.get('href'))[0])
        with open(USERS_LIST, 'w') as f:
            json.dump(result, f)
        print(f"Данные пользователей записаны в {USERS_LIST}")

    def get_mozilla_cves(self, n=3):
        """
        Собираем cve с мозилловского блога
        :param n - количество последних проверяемых ссылок.
        В противном случае придется обрабатывать более 1300 старых ссылок
        """
        url = "https://www.mozilla.org/en-US/security/advisories/"
        resp = self.get_response(url,
                                 bs=True,
                                 parser='lxml',
                                 headers=HEADERS,
                                 )
        result = []
        cnt = 0
        for link in resp.find_all('li', attrs={'class', 'level-item'}):
            cve_dict = {}
            href = link.find('a')
            if href:
                link = urljoin('https://www.mozilla.org', href.get('href', ""))
                resp = self.get_response(link,
                                         bs=True,
                                         parser='lxml',
                                         headers=HEADERS,
                                         )
                # Парсим summary в словарь
                main_sum = resp.find('dl', attrs={'class', 'summary'})
                for name, item in zip(main_sum.find_all('dt'), main_sum.find_all('dd')):
                    cve_dict["_".join(name.text.lower().split())] = item.text.strip()
                cve_dict['cves'] = []
                for cve in resp.find_all('section', attrs={'class', 'cve'}):
                    cve_header = list(map(str.strip, cve.find('a').text[1:].split(':', 1)))
                    cve_dict['cves'].append({
                        'cve': cve_header[0],
                        'short_desc': cve_header[1],
                        'impact': cve.find('span', attrs={'class', 'level'}).text,
                        'long_desc': cve.find('p').text,
                        'links': [link.find("a").get("href")
                                  for link in cve.find_all('li')]
                    })
                result.append(cve_dict)
                cnt += 1
            if cnt >= n:
                break
        print(1)
        return result

    def find_all_issues(self, n=30):
        """
        Сканируем трекер, собираем большинство уязвимостей и печатаем n популярных
        """

        def title_strip(title):
            regex1 = re.compile(r"уязвимость в (.+)$", re.I)
            regex2 = re.compile(r"уязвимости в (.+)$", re.I)
            regex3 = re.compile(r"уязвимость: (.+)$", re.I)
            title_reg = re.findall(regex1, title.text)
            title_reg.extend(re.findall(regex2, title.text))
            title_reg.extend(re.findall(regex3, title.text))
            if title_reg:
                return title_reg[0].strip().lower()

        # ниже идут функции проверки на принадлежность к пакету
        def kernel_str(str_to_check: str) -> str:
            kw_list = [
                'ядро linux',
                'ядру linux',
                'ядра linux',
                'ядре linux',
                'linux-ядра',
            ]
            for kw in kw_list:
                if kw in str_to_check:
                    return 'linux kernel'
            return str_to_check

        def firefox_str(str_to_check: str) -> str:
            return 'firefox' if 'firefox' in str_to_check else str_to_check

        def systemd_str(str_to_check: str) -> str:
            return 'systemd' if 'systemd' in str_to_check else str_to_check

        def nextcloud_str(str_to_check: str) -> str:
            return 'nextcloud' if 'nextcloud' in str_to_check else str_to_check

        def thunderbird_str(str_to_check: str) -> str:
            return 'thunderbird' if 'thunderbird' in str_to_check else str_to_check

        # список из этих функций, чтобы было удобнее итерироваться
        filter_funcs = [
            kernel_str,
            firefox_str,
            systemd_str,
            nextcloud_str,
            thunderbird_str,
        ]

        limit = 100
        # для того, чтобы пройти все страницы с найденными темами потребуется счетчик для оффсета
        cnt = 0
        result = []
        while True:
            url = f"{REDMINE_URL}/projects/cve/search.xml?&issues=1&" \
                  f"limit={limit}&offset={cnt}&titles_only=1&q=уязвимост"
            resp = self.get_response(url,
                                     bs=True,
                                     parser='xml',
                                     headers=HEADERS,
                                     auth=(credentials['REDMINE_USER'],
                                           credentials['REDMINE_PASSWORD'])
                                     )
            titles = resp.find_all("title")
            t_count = len(titles)
            result.extend(list(map(title_strip, titles)))
            result = list(filter(lambda x: x is not None, result))
            for func in filter_funcs:
                result = list(map(func, result))
            cnt += limit
            if t_count < limit:
                break

        for item in Counter(result).most_common(n):
            print(f"{item[0]:<20} {item[1]:>5}")

    @staticmethod
    def user_wants_create_issue() -> bool:
        """
        Проверяем, хочет ли юзер создавать задачу на трекере
        """
        while True:
            human_resp = input("Создать тему в трекере? ")
            if human_resp.lower() not in ['yes', 'y', 'n', 'no']:
                continue
            return True if human_resp in ['yes', 'y'] else False

    def get_dates(self):
        """
        возвращает кортеж строк с датами требуемого формата,
        для последующего использования в запросе api nist.gov
        """
        to_date = f'{date.today().strftime("%Y-%m-%d")}T23:59:59.999-05:00'
        from_date = f'{(date.today() - timedelta(days=self.days_to_check)).strftime("%Y-%m-%d")}T00:00:00.000-05:00'
        return from_date, to_date

    @staticmethod
    def prepare_url(url, queries: dict) -> str:
        """
        собирает ссылку с требуемыми запросами
        """
        url += '?'
        for k, v in queries.items():
            url += f'{k}={v}' if v else k
            url += '&'
        return url[:-1]

    @staticmethod
    def process_urls(urls: list) -> list:
        """
        Ищем ссылки нужного нам вида.
        * https://github.com/torvalds/linux/commit/**commit** - переделывать не надо
        * git.kernel.org - вырезаем хэш коммита и превращаем в ссылку предыдущего вида
        * остальные ссылки не меняем
        """
        result = []
        for link in urls:
            netloc = parse.urlparse(link).netloc
            path = parse.urlparse(link).path
            if netloc == 'git.kernel.org' or (netloc == 'github.com' and path.split('/')[1] == 'torvalds'):
                result.append(f'https://github.com/torvalds/linux/commit/{link.split("/")[-1].split("=")[-1]}')
            else:
                result.append(link)
        # Уберем возможные дубликаты
        result = list(set(result))
        return result

    def get_rpm_path(self, rpm_name, tag_name):
        """
        Возвращает путь до физического расположения пакета на стапеле
        :param tag_name: тег, в котором ищем пакет
        :param rpm_name: Имя пакета
        :return: Путь до файла в случае успеха, None в противном случае
        """
        package = self.get_latest_rpm_data(rpm_name, tag_name)
        if not package:
            return

        src_path = f"{REPO_PATH}/{package['name']}/{package['version']}/{package['release']}" \
                   f"/src/{package['nvr']}.src.rpm"
        return src_path

    def get_kern_patches(self, url: str) -> dict:
        """
        Парсим патч по ссылке, в случае, если ссылка формата
        https://github.com/torvalds/linux/commit/**commit**
        """
        netloc = parse.urlparse(url).netloc
        path = parse.urlparse(url).path
        if not (netloc == 'github.com' and path.split('/')[1] == 'torvalds'):
            return {}

        # Получим response
        new_url = f'{url}.patch'
        patch_resp = self.get_response(new_url, bs=True, headers=HEADERS)
        # sanity check
        if not patch_resp:
            return {}
        patch_txt = patch_resp.find('p').text

        date_re = re.compile(r"Date:\s(.+)")
        fixes_re = re.compile(r"Fixes:\s([a-z0-9]+)")
        subject_re = re.compile(r"Subject:\s(.+)")
        files_raw = re.findall(r"(?<=\s-{3}\s)[\S\s]*?(?=diff)", patch_txt)[0].strip().split('\n')

        return {
            'date': date_re.search(patch_txt).group(1) if date_re.search(patch_txt) else None,
            'fixes': fixes_re.search(patch_txt).group(1) if fixes_re.search(patch_txt) else None,
            'subject': subject_re.search(patch_txt).group(1) if subject_re.search(patch_txt) else None,
            'files_changed': files_raw[-1],
            'files': [file.split('|')[0].strip() for file in files_raw[:-1]],
            'patch_text': patch_txt,
        }

    def get_vim_data(self, desc):
        """
        Функция получения версии уязвимого вима и запуска пересборки нового, если доступно.
        Пока заготовка
        :param desc: Описание узявимости
        :return:
        """

        vim_ver_re = re.compile(r"\d\.\d\.\d+")
        vuln_ver = re.findall(vim_ver_re, desc)[0]
        vim_resp = self.get_response("https://github.com/vim/vim/tags", bs=False)
        vim_source_latest = re.findall(r"archive/refs/tags/[^/]+\.tar\.gz", vim_resp.text)[0]
        latest_vim_ver = re.findall(vim_ver_re, vim_source_latest)[0]
        print(f"https://github.com/vim/vim/{vim_source_latest}")

        if parse_version(vuln_ver) >= parse_version(latest_vim_ver):
            return

        if parse_version(self.vim_73) > parse_version(vuln_ver):
            # TODO выведем сообщение что у нас версия vim не подверженая уязвимости
            return

        print(self.get_rpm_path('vim', self.kojitag73))

    @staticmethod
    def is_kernel_issue(desc, links) -> IsXIssue:
        """
        Проверка на то, что уязвимость относится к ядреной
        """
        kernel_urls = [
            'lore.kernel.org',
            'git.kernel.org',
            'lkml.org',
            'bugzilla.redhat.com',
            'bugzilla.suse.com',
            'cdn.kernel.org',
            'lkml.kernel.org',
            'kernel.dance',
            'lists.debian.org',
            'www.debian.org',
            'www.spinics.net',
        ]

        if ('linux' not in desc) or ('android linux kernel' in desc):
            return IsXIssue.NO

        for link in links:
            netloc = parse.urlparse(link).netloc
            path_first = parse.urlparse(link).path.split('/')[1]
            if (netloc == 'github.com' and path_first == 'torvalds') or (netloc in kernel_urls):
                return IsXIssue.YES

        if 'linux kernel' in desc:
            return IsXIssue.MAYBE

        return IsXIssue.NO

    @staticmethod
    def is_vim_issue(desc, links) -> IsXIssue:
        """
        Проверка на то, что уязвимость относится к vim
        """
        if 'vim' not in desc:
            return IsXIssue.NO

        for link in links:
            netloc = parse.urlparse(link).netloc
            path_first = parse.urlparse(link).path.split('/')[1]
            if netloc == 'github.com' and path_first == 'vim':
                return IsXIssue.YES

        return IsXIssue.MAYBE

    @staticmethod
    def is_nextcloud_issue(desc, links) -> IsXIssue:
        """
        Проверка на то, что уязвимость относится к ядреной
        """

        if 'nextcloud' not in desc:
            return IsXIssue.NO

        for link in links:
            netloc = parse.urlparse(link).netloc
            path_first = parse.urlparse(link).path.split('/')[1]
            if netloc == 'github.com' and path_first == 'nextcloud':
                return IsXIssue.YES

        return IsXIssue.MAYBE

    @staticmethod
    def is_gpac_issue(desc, links) -> IsXIssue:
        """
        Проверка на то, что уязвимость относится к ядреной
        """

        if 'gpac' not in desc:
            return IsXIssue.NO

        for link in links:
            netloc = parse.urlparse(link).netloc
            path_first = parse.urlparse(link).path.split('/')[1]
            if netloc == 'github.com' and path_first == 'gpac':
                return IsXIssue.YES

        return IsXIssue.MAYBE

    @staticmethod
    def is_redis_issue(desc, links) -> IsXIssue:
        """
        Проверка на то, что уязвимость относится к ядреной
        """

        if 'redis' not in desc:
            return IsXIssue.NO

        for link in links:
            netloc = parse.urlparse(link).netloc
            path_first = parse.urlparse(link).path.split('/')[1]
            if netloc == 'github.com' and path_first == 'redis':
                return IsXIssue.YES

        return IsXIssue.MAYBE

    @staticmethod
    def is_systemd_issue(desc, links) -> IsXIssue:
        """
        Проверка на то, что уязвимость относится к ядреной
        """

        if 'systemd' not in desc:
            return IsXIssue.NO

        for link in links:
            netloc = parse.urlparse(link).netloc
            path_first = parse.urlparse(link).path.split('/')[1]
            if netloc == 'github.com' and path_first == 'systemd':
                return IsXIssue.YES

        return IsXIssue.MAYBE

    @staticmethod
    def is_django_issue(desc, links) -> IsXIssue:
        """
        Проверка на то, что уязвимость относится к ядреной
        """
        django_urls = [
            'docs.djangoproject.com',
            'www.djangoproject.com',
        ]
        if 'django' not in desc:
            return IsXIssue.NO

        for link in links:
            netloc = parse.urlparse(link).netloc
            if netloc in django_urls:
                return IsXIssue.YES

        return IsXIssue.MAYBE

    @staticmethod
    def is_moodle_issue(desc, links) -> IsXIssue:
        """
        Проверка на то, что уязвимость относится к ядреной
        """
        moodle_urls = [
            'git.moodle.org',
            'moodle.org',
        ]
        if 'django' not in desc:
            return IsXIssue.NO

        for link in links:
            netloc = parse.urlparse(link).netloc
            if netloc in moodle_urls:
                return IsXIssue.YES

        return IsXIssue.MAYBE

    def get_issue(self, name, cve, desc, links, check_patch=True) -> dict:
        """
        Разбираем nist json на нужный нам словарь
        :param name: имя пакета, по которому мы потом будем сортировать уязвимости
        :param cve: json с уязвимостью
        :param desc: вытащеное из него описание
        :param links: обработаные URL'ы
        :param check_patch: Будем вытаскивать патчи. Работает для ядра
        :return: словарь с разобраным добром
        """
        patch, scores = [], {}

        if check_patch:
            for link in links:
                patch_resp = self.get_kern_patches(link)
                if patch_resp:
                    patch.append(patch_resp)

        for key in cve['cve']['metrics'].keys():
            scores[cve['cve']['metrics'][key][0]['cvssData']['version']] = \
                cve['cve']['metrics'][key][0]['cvssData']['baseScore']

        return {
            'id': cve['cve']['id'],
            'name': name,
            'description': desc,
            'published': cve['cve']['published'],
            'lastModified': cve['cve']['lastModified'],
            'status': cve['cve']['vulnStatus'],
            'links': links,
            'scores': scores,
            'patch': patch,
        }

    def get_one_cve(self, cve_id: str, check_patch=False) -> dict:
        """
        Номер в виде CVE-2023-1234 на входе, словарь с данными на выходе
        """
        params = {
            NIST_CVE: cve_id,
        }
        url = self.prepare_url(NIST_API_URL, params)
        nist_resp = self.get_response(url, bs=False, headers=HEADERS)
        nist_json = nist_resp.json() if nist_resp else None
        if not nist_json or not nist_json.get('vulnerabilities', ""):
            return {}

        cve = nist_json.get('vulnerabilities')[0]
        desc = cve['cve']['descriptions'][0]['value'].lower()
        links = self.process_urls([link['url'] for link in cve['cve']['references']])

        return self.get_issue('unknown', cve, desc, links, check_patch=check_patch)

    def check_cve(self,
                  pkg_name,
                  check_func,
                  cve,
                  desc,
                  links,
                  cve_data_list,
                  cve_id_list,
                  cve_count,
                  exists_count
                  ):
        """
        Фильтруем уязвимости на нужные/ненужные
        :param pkg_name: Имя пакета, на который проверяем
        :param check_func: Функция, которая проверяет на принадлекжность к пакету
        :param cve: Словарь с данными по уязвимости
        :param desc: слегка обработанное описание уязвимости
        :param links: обработанные (в случае ядра) ссылки предоставленные nist'om
        :param cve_data_list: общий список данных по отфильтрованным уязвимостям
        :param cve_id_list: общий список id отфильтрованных уязвимостей
        :param cve_count: счетчик релевантных уязвимостей
        :param exists_count: счетчик уже существующих на трекере уязвимостей
        :return: Вщвзвращаем счетчики уязвимостей обратно
        """

        is_pkg = check_func(desc, links)
        if is_pkg == IsXIssue.YES:
            cve_count += 1
            cve_id_list.append(cve['cve']['id'])
            # Проверим, заведена ли уже задача по данной CVE
            if CHECK_REDMINE and self.is_cve_exists_rest_api(cve['cve']['id']):
                exists_count += 1
                return cve_count, exists_count
            cve_data_list.append(self.get_issue(pkg_name, cve, desc, links))
            return cve_count, exists_count

        elif is_pkg == IsXIssue.MAYBE:
            self.manual_check.append(cve['cve']['id'])

        return cve_count, exists_count

    def get_current_cves(self, date_from: str, date_to: str) -> list:
        """
        Соберем все cve между датами.
        Формат даты:
        date1 = '2023-03-01T00:00:00.000-05:00'
        date2 = '2023-03-02T23:59:59.999-05:00'
        """
        cve_data_list, cve_id_list = [], []
        exists_count = 0

        # Получим response
        params = {
            NIST_REJ: None,
            NIST_START: date_from,
            NIST_END: date_to
        }
        url = self.prepare_url(NIST_API_URL, params)
        nist_resp = self.get_response(url, bs=False, headers=HEADERS)

        nist_json = nist_resp.json() if nist_resp else None
        if not nist_json or not nist_json.get('vulnerabilities', ""):
            return []

        total_res = nist_json['totalResults']
        print(f'Total CVE found:          {total_res}')
        for cve in nist_json.get('vulnerabilities'):

            # подготовим данные для проверки
            desc = cve['cve']['descriptions'][0]['value'].lower()
            links = self.process_urls([link['url'] for link in cve['cve']['references']])

            for pkg_name, pkg_data in self.pkgs_data.items():
                pkg_data['cve_counter'], exists_count = self.check_cve(pkg_name,
                                                                       pkg_data['check_func'],
                                                                       cve,
                                                                       desc,
                                                                       links,
                                                                       cve_data_list,
                                                                       cve_id_list,
                                                                       pkg_data['cve_counter'],
                                                                       exists_count)

        print('-' * 80)
        print("CVEs")
        print('-' * 80)
        for pkg_name, pkg_data in self.pkgs_data.items():
            # классная арифметическая конструкция - для вычисления пробелов
            print(f"{pkg_name}:" + " " * (30 - (len(pkg_name) + 5)) + f"{pkg_data['cve_counter']}")
        print('-' * 80)
        print(f"CVE list:                 {', '.join(cve_id_list)}")
        print(f"Manual check:             {', '.join(self.manual_check)}")
        print(f"CVE existed on a tracker: {exists_count}")
        return cve_data_list

    @staticmethod
    def get_issue_str(cve: dict) -> str:
        """
        Формирует строку для последующего создания темы на трекере
        """
        result = ""
        result += f"h5. Уязвимость {cve['id']}\n\n"
        result += f"Описание:\n"
        result += f"{cve['description']}\n\n"
        if cve['scores']:
            result += f'Важность:\n'
            for k, v in cve['scores'].items():
                result += f"* *CVSS {k}: {v}*\n"
        if cve['patch']:
            for item in cve['patch']:
                result += f'\nДанные патча:\n\n'
                result += f"* Дата: {item['date']}\n"
                if item['fixes']:
                    result += f"* Уязвимый коммит: https://github.com/torvalds/linux/commit/" \
                              f"{item['fixes']}\n"
                result += f"* Тема: {item['subject']}\n"
                result += f"* Изменения: {item['files_changed']}\n"
                result += f"\nФайл(ы):\n\n"
                for filename in item['files']:
                    result += f"* *{filename}*\n"
        result += f"\nСсылки:\n\n"
        for link in cve['links']:
            result += f"* {link}\n"
        result += f"\nИсточник:\n\n"
        result += f"* https://nvd.nist.gov/vuln/detail/{cve['id']}\n\n"
        return result

    def create_an_issue(self,
                        subject,
                        desc: str,
                        assigned_id=23,
                        watcher_ids=None,
                        tag=None,
                        ):
        """
        Создает тему на трекере.
        :param subject: Тема задачи
        :param desc: Описание
        :param assigned_id: кому назначена
        :param watcher_ids: Кто наблюдатель
        :param tag: тег
        :return: id задачи
        """
        # if watcher_ids is None:
        #     watcher_ids = [490]
        issue = self.redmine.issue.create(
            project_id=297,  # 297 Уязвимости
            subject=subject,  # заголовок
            tracker_id=10,  # 10 - класс "Задача"
            description=desc,  # тело задачи
            status_id=1,  # 1 - новая
            fixed_version_id=146,  # 146 - Версия: РЕД ОС - РЕД ОС 7.3
            priority_id=1,  # 1 - нормальный приоритет
            assigned_to_id=assigned_id,
            watcher_user_ids=watcher_ids,  # 490 - Чернышев Артем, 25 - Шапошников Олег
            custom_fields=[{'id': 151, 'value': 'Все'},  # Конфигурация ОС: Все
                           {'id': 133, 'value': ['143', '144']},  # 143, 144 - Редакция: Сертифицированная, Стандартная
                           ],
            tag_list=[
                tag  # Метка: например kernel
            ],
        )
        return issue.id

    @staticmethod
    def apply_patches(src_path, patch_path) -> PatchResult:
        """
        Пытаемся применить патч к требуемому дереву сорцов.
        """

        ps = subprocess.Popen(f"patch -p 1 --dry-run < {patch_path}",
                              shell=True,
                              cwd=src_path,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        git_status = ps.communicate()[0].decode('utf-8')
        if 'FAILED' in git_status:
            return PatchResult.FAILED
        elif 'previously applied' in git_status:
            return PatchResult.ALREADY_APPLIED
        elif "can't find file" in git_status:
            return PatchResult.NO_FILE
        else:
            return PatchResult.SUCCESS

    def prepare_issue(self, cve_list, kernel_issue=False, check_patch=False):
        """
        Подготавливаем строки для создания задачи в трекере либо для печати в stdout
        :param cve_list: список подготовленных словарей
        :param kernel_issue: флаг, что уязвимости ядреные
        :param check_patch: флаг, что мы хотим проверять патчи. Пока только для ядра
        :return: возвращаем строку, список найденых патчей и удачных применений патчей
        """
        issues = ""
        patches_found = 0
        successful_patches_list = []

        for single_cve in cve_list:
            issues += self.get_issue_str(single_cve)

            if not single_cve['patch'] and not check_patch:
                continue
            patches_found += 1
            for i, patch in enumerate(single_cve['patch']):
                patch_path = f"{TMP_PATCHES_PATH}/000{i + 1}_{single_cve['id']}.patch"
                with open(patch_path, "w") as f:
                    f.write(patch['patch_text'])
                # Пробуем применить патч к актуальной версии ядра
                if CHECK_PATCH:
                    patching_result = self.apply_patches(self.kernel_73_path,
                                                         patch_path)
                    issues += "Актуальность патча:\n"
                    if patching_result == PatchResult.FAILED:
                        issues += "* Не удалось применить\n\n"
                    elif patching_result == PatchResult.ALREADY_APPLIED:
                        issues += "* Уже применен\n\n"
                    elif patching_result == PatchResult.NO_FILE:
                        issues += "* Нет файла для применения\n\n"
                    elif patching_result == PatchResult.SUCCESS:
                        issues += "* Применен успешно\n\n"
                        successful_patches_list.append((patch_path, single_cve['id']))

            issues += "---\n\n"

        if issues and kernel_issue:
            if self.kernel_72 == self.kernel_73:
                issues += f"\nОценить уязвимость ядра версии {self.kernel_73}\n"
            else:
                issues += f"\nОценить уязвимость ядер версий {self.kernel_72} и {self.kernel_73}\n"

        return issues, patches_found, successful_patches_list

    @staticmethod
    def send_to_telegram(message: str) -> dict:
        """
        Послать строку в телеграм
        :param message: строка, которую посылаем
        :return: Возвращает ответ от телеги в случае успеха
        """
        group_id = credentials['TELEGRAM_GROUP_ID']
        bot_token = credentials['BOT_TOKEN']
        send_command = f"curl -s --data 'text={message}' --data 'chat_id={group_id}' " \
                       f"'https://api.telegram.org/bot'{bot_token}'/sendMessage'"
        ps = subprocess.Popen(send_command,
                              shell=True,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        result = ps.communicate()[0].decode('utf-8')
        # TODO сделать try-except
        return json.loads(result)

    def check_and_post(self,
                       pkg_name,
                       all_cves,
                       is_kernel: bool,
                       check_patch: bool,
                       assigned_id=23,  # 23 - Владимир Чиркин
                       watcher_ids=None,
                       ):
        """
        Подготавливаем к печати/публикованию уязвимости, собранные на предыдущем этапе.
        Разделяем по пакетам: ядро, вим и т.д.
        :param pkg_name: Имя пакета
        :param all_cves: Полный список отобранных cve
        :param is_kernel: Флаг ядреной уязвимости
        :param check_patch: Проверяли патчи или нет
        :param assigned_id: Кому назначено
        :param watcher_ids: Кто наблюдатели (в виде list'a)
        :return:
        """

        pkg_cves = list(filter(lambda x: x['name'] == pkg_name, all_cves))
        issues, patches_found, successful_patches_list = self.prepare_issue(pkg_cves,
                                                                            kernel_issue=is_kernel,
                                                                            check_patch=check_patch)
        if check_patch:
            print(f"{pkg_name} patches found:     {patches_found}\n")
        if issues:
            print(issues)
        if not (CREATE_AN_ISSUE and pkg_cves and self.redmine):
            return
        if not self.auto and not self.user_wants_create_issue():
            return
        if is_kernel:
            subject = 'Множественные уязвимости в ядре Linux' \
                if (len(pkg_cves) > 1) else 'Уязвимость в ядре Linux'
            issue_id = self.create_an_issue(subject=subject,
                                            desc=issues,
                                            assigned_id=assigned_id,
                                            watcher_ids=watcher_ids,
                                            tag=pkg_name)
        else:
            subject = f'Множественные уязвимости в {pkg_name.capitalize()}' \
                if (len(pkg_cves) > 1) else f'Уязвимость в {pkg_name.capitalize()}'
            issue_id = self.create_an_issue(subject=subject,
                                            desc=issues,
                                            assigned_id=assigned_id,
                                            watcher_ids=watcher_ids
                                            )

        if is_kernel and check_patch and successful_patches_list:
            for i, item in enumerate(successful_patches_list):
                dest_patch = f"{DEST_PATCH_PATH}/patches-{self.kernel_73}/" \
                             f"000{i}_kernel-lt-{self.kernel_73}_{item[1]}_{issue_id}.patch"
                Path(item[0]).rename(dest_patch)
                print(f"Patch created: {dest_patch}")

        print(f"Создана задача № {issue_id}")
        issue_url = f"{REDMINE_URL}/issues/{issue_id}"
        print(issue_url)

        if SEND_TO_TELEGRAM:
            self.send_to_telegram(f"Manual check:"
                                  f" {', '.join(self.manual_check)}\nTracker URL: {issue_url}")

    def run(self):
        """
        Основной цикл
        """
        all_cves = self.get_current_cves(*self.get_dates())
        for pkg_name, pkg_data in self.pkgs_data.items():
            self.check_and_post(pkg_name,
                                all_cves,
                                is_kernel=pkg_data['is_kernel'],
                                check_patch=pkg_data['check_patch'],
                                assigned_id=pkg_data['assigned_to'],
                                watcher_ids=pkg_data['watchers'])


def parse_args():
    parser = argparse.ArgumentParser(
        description="Скрипт для парсинга Linux Kernel CVE, поиска патчей и создания темы на трекере")

    parser.add_argument(
        '-d',
        '--day',
        type=int,
        default=1,
        help="Количество дней за которые смотрим уязвимости. Считаем от текущего"
    )
    parser.add_argument(
        '--cve',
        type=str,
        help="Вывести в консоль данные по конкретной CVE"
    )
    parser.add_argument(
        '--exists',
        action='store_true',
        help="Проверяем, есть ли такая тема на трекере. В случае если не проверяем, "
             "тема создаваться не будет."
    )
    parser.add_argument(
        '--no-exists',
        dest='exists',
        action='store_false',
    )
    parser.add_argument(
        '--patch-check',
        action='store_true',
        help="Проверять патч на локальных сорцах ядра требуемой версии"
    )
    parser.add_argument(
        '--no-patch-check',
        dest='patch_check',
        action='store_false',
    )
    parser.add_argument(
        '--auto',
        action='store_true',
        help="Автоматическое создание темы или спрашиваем у юзера"
    )
    parser.add_argument(
        '--no-auto',
        dest='auto',
        action='store_false',
    )
    parser.add_argument(
        '--send',
        action='store_true',
        help="Посылаем тему в телегу или нет."
    )
    parser.add_argument(
        '--no-send',
        dest='send',
        action='store_false',
    )
    parser.add_argument(
        '--tracker',
        action='store_true',
        help="Создаем тему или нет."
    )
    parser.add_argument(
        '--no-tracker',
        dest='tracker',
        action='store_false',
    )
    parser.add_argument(
        '--stat',
        action='store_true',
        help="Статистика по уязвимостям на трекере"
    )
    parser.add_argument(
        '--users',
        action='store_true',
        help="Создать файл со списком юзеров редмайна"
    )
    parser.add_argument(
        '--moz',
        action='store_true',
        help="Создать файл со списком юзеров редмайна"
    )
    parser.set_defaults(exists=True)
    parser.set_defaults(tracker=True)
    parser.set_defaults(auto=True)
    parser.set_defaults(patch_check=True)
    parser.set_defaults(send=True)
    parser.set_defaults(stat=False)
    parser.set_defaults(users=False)
    parser.set_defaults(moz=False)
    return parser.parse_args()


if __name__ == '__main__':
    arguments = parse_args()
    DAYS_TO_CHECK = arguments.day
    SEND_TO_TELEGRAM = arguments.send
    CHECK_REDMINE = arguments.exists
    CHECK_PATCH = arguments.patch_check
    CREATE_AN_ISSUE = arguments.tracker and CHECK_REDMINE
    AUTO = arguments.auto
    CVE = arguments.cve
    STAT = arguments.stat
    USERS = arguments.users
    MOZ = arguments.moz

    cve_checker = CveChecker(DAYS_TO_CHECK, NUMBER_OF_RECON, AUTO)
    if CVE:
        one_cve = cve_checker.get_one_cve(CVE, check_patch=True)
        print(cve_checker.get_issue_str(one_cve))
        exit(0)
    if STAT:
        cve_checker.find_all_issues()
        exit(0)
    if USERS:
        cve_checker.get_users_list()
        exit(0)
    if MOZ:
        cve_checker.get_mozilla_cves()
        exit(0)
    print(80 * "=")
    print(f"Current time:             {datetime.now().strftime('%H:%M:%S %d-%m-%Y')}")
    print(f"Checking CVE's for last:  {DAYS_TO_CHECK} day(s)")
    cve_checker.run()
    print(80 * "=")
