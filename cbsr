#!/home/tenebrae/devel/cbsr/venv/bin/python3

import re
import os
import csv
import json
import shutil
import urllib3
# import vulners
import requests
import argparse
import subprocess
import redminelib
from time import sleep
import urllib.parse as parse
from bs4 import BeautifulSoup
from redminelib import Redmine
from collections import Counter
from itertools import chain
from dotenv import dotenv_values
from urllib.parse import urljoin
from datetime import timedelta, date, datetime
from pkg_handlers import USERS_LIST, PkgHandler, IsXIssue, PatchResult

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
# TODO Заменить хардкод
os.chdir("/home/tenebrae/devel/cbsr/")

# Get the path to the directory this file is in
ENV_PATH = os.path.abspath(os.path.dirname(__file__))
credentials = dotenv_values(f"{ENV_PATH}/.env")

# ############################ КОНСТАНТЫ #############################
NUMBER_OF_RECON = 0
SAVE_PATCHES = False  # Сохранять успешно примененные патчи на диск или нет
VULN_PROJECT = 297
KERN_PROJECT = 787

REPO_PATH = credentials['REPO_PATH']
REDMINE_URL = credentials['REDMINE_URL']

NIST_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
NIST_CVE = "cveId"
NIST_REJ = "noRejected"
NIST_START = "pubStartDate"
NIST_END = "pubEndDate"

KERNEL_ML_GIT_PATH = f"{os.path.expanduser('~')}/devel/kernel/src/linux-ml"
KERNEL_ST_5_15_GIT_PATH = f"{os.path.expanduser('~')}/devel/kernel/src/linux-5.15.y"
KERNEL_ST_6_1_GIT_PATH = f"{os.path.expanduser('~')}/devel/kernel/src/linux-6.1.y"
KERNEL_ST_6_6_GIT_PATH = f"{os.path.expanduser('~')}/devel/kernel/src/linux-6.6.y"

KERN_PATH_DICT = {
    "mainline": KERNEL_ML_GIT_PATH,
    "5.15.y": KERNEL_ST_5_15_GIT_PATH,
    "6.1.y": KERNEL_ST_6_1_GIT_PATH,
    "6.6.y": KERNEL_ST_6_6_GIT_PATH,
}

KERNEL_PATH = f"{os.path.expanduser('.')}/src"
TMP_PATCHES_PATH = f"{os.getcwd()}/output/tmp-patches"
DEST_PATCH_PATH = f"{os.getcwd()}/output/patches"
CSV_PATH = f"{os.getcwd()}/output/csv"

TMP_SRPM_PATH = f"{os.getcwd()}/output/srpms"

HEADERS = {
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,'
              'application/signed-exchange;v=b3;q=0.9',
    'Accept-Language': 'en-US,en;q=0.9,ru;q=0.8',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) '
                  'Chrome/102.0.5005.167 Safari/537.36',
}


# ######################################################################
# Print iterations progress
# https://stackoverflow.com/questions/3173320/text-progress-bar-in-terminal-with-block-characters
def print_progress_bar(iteration, total, prefix='', suffix='', decimals=1, length=100, fill='█', print_end="\r"):
    """
    Call in a loop to create terminal progress bar
    @params:
        iteration   - Required  : current iteration (Int)
        total       - Required  : total iterations (Int)
        prefix      - Optional  : prefix string (Str)
        suffix      - Optional  : suffix string (Str)
        decimals    - Optional  : positive number of decimals in percent complete (Int)
        length      - Optional  : character length of bar (Int)
        fill        - Optional  : bar fill character (Str)
        print_end   - Optional  : end character (e.g. "\r", "\r\n") (Str)
    """
    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
    filled_length = int(length * iteration // total)
    bar = fill * filled_length + '-' * (length - filled_length)
    print(f'\r{prefix} |{bar}| {percent}% {suffix}', end=print_end)
    # Print New Line on Complete
    if iteration == total:
        print()


def flatten_chain(matrix):
    return list(chain.from_iterable(matrix))


def get_response(*args, bs=True, parser='lxml', **kwargs):
    """
    Получим ответ по url
    * bs - вернуть как soup или обычные response
    * parser - какой парсер страницы используем (html, xml, lxml)
    * NUMBER_OF_RECON - глобальная опция. Сколько стучимся, если поймали ошибку соединения
    """
    # response: requests.Response = requests.get(*args, **kwargs)
    # if bs and response.status_code == requests.codes.ok:
    #     return BeautifulSoup(response.text, parser)
    # elif bs and response.status_code != requests.codes.ok:
    #     return None
    # else:
    #     return response

    recon_count = 0
    while recon_count <= NUMBER_OF_RECON:
        try:
            response: requests.Response = requests.get(*args, **kwargs)
            # проверим код ответа
            if response.status_code != requests.codes.ok:
                raise ConnectionError
            sleep(0.1)
            if bs:
                return BeautifulSoup(response.text, parser)
            else:
                return response
        except ConnectionError:
            # Стучимся пока не соединимся.
            sleep(0.250)
            recon_count += 1
            return response

    # print(f'Ошибка соединения')


def get_users_list():
    """
    создает файл со списком юзеров трекера с их номерами
    :return:
    """
    result = {}
    url = f"{REDMINE_URL}/users?per_page=500"
    resp = get_response(url,
                        bs=True,
                        parser='xml',
                        headers=HEADERS,
                        auth=(credentials['REDMINE_USER'], credentials['REDMINE_PASSWORD']),
                        verify=False
                        )
    for user in resp.findAll('tr', {'class': lambda x: x and 'user active' in x}):
        user_mail = user.find('td', {'class': 'mail'})
        user_lnk = user.find('a')
        if user_mail and user_lnk:
            user_name = re.findall(r"^(.+)@", user_mail.text)
            user_id = re.findall(r"\d+", user_lnk.get('href'))
            if user_name and user_id:
                result[user_name[0]] = int(user_id[0])

    with open(USERS_LIST, 'w') as f:
        json.dump(result, f)
    print(f"Данные пользователей записаны в {USERS_LIST}")


class CveChecker:

    @staticmethod
    def __redmine_auth():
        """
        Простой wrapper для авторизации
        """
        redmine = Redmine(REDMINE_URL,
                          username=credentials['REDMINE_USER'],
                          password=credentials['REDMINE_PASSWORD'],
                          requests={'verify': False})
        try:
            redmine.auth()
            return redmine
        except redminelib.exceptions.AuthError:
            print("Auth Failed")
            return None

    # @staticmethod
    # def __vulners_auth():
    #     vulners_api = vulners.VulnersApi(api_key=credentials['VULNERS_KEY'])
    #     return vulners_api

    @staticmethod
    def exec_bash(bash_cmd: str) -> str:
        """
        Простая обертка для выполнения bash-команд
        :param bash_cmd: Команда в строковом формате
        :return: Возвращает результат выполнения в UTF-8 кодировке
        """
        ps = subprocess.Popen(bash_cmd,
                              shell=True,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.DEVNULL)
        return ps.communicate()[0].decode('utf-8')

    @staticmethod
    def get_hash(url: str) -> str:
        """
        Получить хэш коммита из стандартного url'a
        """
        splitted_url = url.split('/')
        return splitted_url[-1] if splitted_url[-2] == 'commit' else ''

    @staticmethod
    def grep_cve(text) -> list:
        regex = re.compile(r"[A-Z]{3}.{0,2}-\d{4}-\d{4,7}")
        return re.findall(regex, text)

    def download_kernel_src(self, kern_ver: str):
        """
        Качаем сорцы ядра требуемой версии и распаковываем
        :param kern_ver: версия ядра
        :return:
        """
        kern_src_url = f"https://cdn.kernel.org/pub/linux/kernel/" \
                       f"v{kern_ver.split('.')[0]}.x/linux-{kern_ver}.tar.xz"
        kernel_src_filename = f"{KERNEL_PATH}/linux-{kern_ver}.tar.xz"

        # Качаем архив
        req = get_response(kern_src_url, bs=False)
        with open(kernel_src_filename, "wb") as f:
            for chunk in req.iter_content(100000):
                f.write(chunk)

        # Распаковываем в папку и удаляем архив
        unpack_cmd = f"tar xf {kernel_src_filename} -C {KERNEL_PATH}"
        rm_cmd = f"rm -f {kernel_src_filename}"
        self.exec_bash(unpack_cmd)
        self.exec_bash(rm_cmd)

    def __prepare_dirs_and_paths(self):
        """
        Проверяем на существование требуемые папки
        """

        if not os.path.exists(KERNEL_PATH):
            os.makedirs(KERNEL_PATH)

        if not os.path.exists(USERS_LIST):
            get_users_list()

        for kernel_data in self.pkg_handler.pkgs_data['kernel']['nvr_list']:
            self.kernel_paths.append(f"{KERNEL_PATH}/linux-{kernel_data}")
            if not os.path.exists(f"{DEST_PATCH_PATH}/patches-{kernel_data}"):
                os.makedirs(f"{DEST_PATCH_PATH}/patches-{kernel_data}")

        # если нет сорцов для какой либо версии проверяемых ядер - скачиваем и распаковываем их
        for kern_path in set(self.kernel_paths):
            if not os.path.exists(kern_path):
                print(f"Downloading sources for linux kernel: {kern_path}")
                self.download_kernel_src(re.findall(self.ver_re, kern_path)[0])

        for path in [TMP_PATCHES_PATH, TMP_SRPM_PATH, CSV_PATH]:
            if os.path.exists(path):
                shutil.rmtree(path, ignore_errors=False, onerror=None)
            os.makedirs(path)

    def __init__(self, days_to_check, recon_num, auto):

        self.redmine = self.__redmine_auth()
        # self.vulners = self.__vulners_auth()

        self.ver_re = re.compile(r"\d\.\d+\.\d+")
        self.pkg_handler = PkgHandler()
        self.days_to_check = days_to_check
        self.recon_num = recon_num
        self.auto = auto
        self.manual_check = []
        self.kernel_paths = []

        self.__prepare_dirs_and_paths()

    @staticmethod
    def is_cve_exists_rest_api(cve: str, return_link=False) -> (bool, []):
        """
        Костыльная проверка на существование CVE в трекере.
        Используется, пока не разберусь с оберткой redminelib
        """
        url = f"{REDMINE_URL}/projects/cve/search.xml?&scope=subprojects&issues=1&q={cve}"
        # Так как редмайн ищет все вхождения подстроки, мы можем
        # проигнорировать CVE сами того не желая.
        # Например: CVE-2023-1281 при наличии на трекере CVE-2023-12811
        # посчитается как существующая
        exact_search_re = re.compile(fr"\b{cve}\b", re.I)

        resp = get_response(url,
                            bs=True,
                            parser='xml',
                            headers=HEADERS,
                            auth=(credentials['REDMINE_USER'], credentials['REDMINE_PASSWORD']),
                            verify=False
                            )
        # Найдем, сколько раз CVE встречается в поиске
        f_count = resp.find("results").get("total_count")
        tracker_link_ids = []
        try:
            if int(f_count):
                # проверяем, если есть совпадение в описании
                is_exist = bool(exact_search_re.findall(resp.find("description").text))
                # или в названии темы
                is_exist = is_exist or any([exact_search_re.findall(item.text)
                                            for item in resp.find("results").find_all('title')])
                if is_exist and return_link:
                    tracker_link_ids = [item.text for item in resp.find('results').find_all('id')]
                return is_exist, sorted(tracker_link_ids)
            return False, tracker_link_ids
        except ValueError:
            print("Ошибка поиска")
            return False, tracker_link_ids

    @staticmethod
    def create_mozcve(url) -> dict:
        cve_dict = {}
        resp = get_response(url,
                            bs=True,
                            parser='lxml',
                            headers=HEADERS,
                            )
        # Парсим summary в словарь
        main_sum = resp.find('dl', attrs={'class', 'summary'})
        for name, item in zip(main_sum.find_all('dt'), main_sum.find_all('dd')):
            cve_dict["_".join(name.text.lower().split())] = item.text.strip()
        cve_dict['cves'] = []
        for cve in resp.find_all('section', attrs={'class', 'cve'}):
            cve_header = list(map(str.strip, cve.find('a').text[1:].split(':', 1)))
            cve_dict['cves'].append({
                'id': cve_header[0],
                'name': cve_dict['products'].lower().capitalize().split(',')[0].split()[0],
                'vuln_products': cve_dict['products'],
                'fixed_in': cve_dict['fixed_in'],
                'description': f"*{cve_header[1]}*\n{cve.find('p').text}",
                'impact': cve.find('span', attrs={'class', 'level'}).text,
                'links': [link.find("a").get("href")
                          for link in cve.find_all('li')],
                'source': f"{url}#{cve_header[0]}",
            })
        return cve_dict

    def get_chrome_cves(self) -> []:
        result = []

        url = 'https://chromereleases.googleblog.com/search/label/Stable%20updates'
        resp = get_response(url,
                            bs=True,
                            parser='lxml',
                            headers=HEADERS,
                            )
        if not resp:
            return result

        visited_urls = []
        if os.path.exists('./visited_chrome_urls.log'):
            # Загружаем список уже посещенных урлов
            with open('./visited_chrome_urls.log', 'r') as url_file:
                visited_urls = list(map(str.strip, url_file.readlines()))

        for item in resp.find_all('h2', attrs={'class': 'title'}):
            if item.text.strip() == 'Stable Channel Update for Desktop':
                link = item.find('a').get('href')

                if link in visited_urls:
                    continue

                result.extend(self.create_chromecve(link))
                with open('./visited_chrome_urls.log', 'a') as url_file:
                    url_file.write(f"{link}\n")

        return result

    @staticmethod
    def create_chromecve(url) -> []:
        cve_list = []

        if not url:
            return cve_list

        resp = get_response(url,
                            bs=True,
                            parser='lxml',
                            headers=HEADERS,
                            )
        if not resp:
            return cve_list

        search_re = re.compile(r"CVE-\d{4}-\d{4,7}", re.I)
        resp_body = resp.find('div', attrs={"class": "post-body"})
        version_raw = next(iter(resp_body.find_all('p')))
        version_raw_str = version_raw.text if version_raw else None

        if not version_raw_str:
            return cve_list

        ver_re = re.compile(r"(?i)([\d\W]+)\s+for\s+linux")
        ver_list = ver_re.findall(version_raw_str)

        if not ver_list:
            return cve_list

        ver_str = ver_list[0].strip()

        for item in resp_body.find_all('p', attrs={'dir': 'ltr'}):
            raw_cve_data = search_re.findall(item.text)
            if not raw_cve_data:
                continue
            processed_cve_str = re.split('(Reported)', item.text.split(" ", 1)[1:][0])[0].strip()
            cve_list.append({
                'id': processed_cve_str.split(':')[0].split()[1],
                'name': 'Chromium',
                'impact': processed_cve_str.split(':')[0].split()[0],
                'description': processed_cve_str.split(':')[1].strip(),
                'fixed_in': ver_str,
                'source': url,
            })

        return cve_list


    def get_mozilla_cves(self, n=3):
        """
        Собираем cve с мозилловского блога
        :param n - количество последних проверяемых ссылок.
        В противном случае придется обрабатывать более 1300 старых ссылок
        """
        url = "https://www.mozilla.org/en-US/security/advisories/"
        resp = get_response(url,
                            bs=True,
                            parser='lxml',
                            headers=HEADERS,
                            )
        visited_urls = []
        if os.path.exists('./visited_urls.log'):
            # Загружаем список уже посещенных урлов
            with open('./visited_urls.log', 'r') as url_file:
                visited_urls = list(map(str.strip, url_file.readlines()))
        result = []
        cnt = 0
        for link in resp.find_all('li', attrs={'class', 'level-item'}):
            if cnt >= n:
                break
            href = link.find('a')
            if href:
                cnt += 1
                link = urljoin('https://www.mozilla.org', href.get('href', ""))
                if link in visited_urls:
                    continue
                # добавляем новый урл в список посещенных
                result.append(self.create_mozcve(link))
                with open('./visited_urls.log', 'a') as url_file:
                    url_file.write(f"{link}\n")
        return result

    @staticmethod
    def get_zero_cves() -> list:

        url = "https://www.zerodayinitiative.com/advisories/published/"
        resp = get_response(url,
                            bs=True,
                            parser='lxml',
                            headers=HEADERS,
                            )
        result = []
        for tr in resp.find_all("tr", attrs={"id": "publishedAdvisories"}):
            tds = tr.find_all("td")
            if tds[2].text.lower() == 'linux':
                current_url = f"https://www.zerodayinitiative.com/advisories/{tds[0].text}/"
                resp = get_response(current_url,
                                    bs=True,
                                    parser='lxml',
                                    headers=HEADERS,
                                    )
                table_tr_list = resp.find("table").find_all("tr")
                if table_tr_list[3].find_all("td")[1].text.strip().lower() == 'kernel':
                    long_desc = table_tr_list[4].find_all("td")[1].text.strip()
                    links = [url.text.strip() for url in table_tr_list[5].find_all("a")]
                    result.append({
                        "zdi_id": tds[0].text,
                        "name": 'kernel',
                        "zdi_can": tds[1].text,
                        "vendor": tds[2].text,
                        "id": tds[3].text if (tds[3].text and tds[3].text != '\xa0') else tds[1].text,
                        "cvss": tds[4].text,
                        "date": tds[5].text,
                        "updated": tds[6].text,
                        "short_desc": tds[7].text,
                        "description": long_desc,
                        "source": f"https://www.zerodayinitiative.com/advisories/{tds[0].text}/",
                        "links": links
                    })

        return result

    @staticmethod
    def user_wants_create_issue() -> bool:
        """
        Проверяем, хочет ли юзер создавать задачу на трекере
        """
        while True:
            human_resp = input("Создать тему в трекере? ")
            if human_resp.lower() not in ['yes', 'y', 'n', 'no']:
                continue
            return True if human_resp in ['yes', 'y'] else False

    def get_dates(self, today=True):
        """
        возвращает кортеж строк с датами требуемого формата,
        для последующего использования в запросе api nist.gov
        """
        to_date = f'{date.today().strftime("%Y-%m-%d")}' \
                  f'T23:59:59.999-05:00'

        if not today and START_DATE:
            from_date = f'{datetime.strptime(START_DATE, "%d-%m-%Y").strftime("%Y-%m-%d")}T00:00:00.000-05:00'
            tmp_date = datetime.strptime(START_DATE, "%d-%m-%Y") + timedelta(days=self.days_to_check)
            to_date = f'{tmp_date.strftime("%Y-%m-%d")}T23:59:59.999-05:00'
            return from_date, to_date

        from_date = f'{(date.today() - timedelta(days=self.days_to_check)).strftime("%Y-%m-%d")}' \
                    f'T00:00:00.000-05:00'

        return from_date, to_date

    @staticmethod
    def prepare_url(url, queries: dict) -> str:
        """
        собирает ссылку с требуемыми запросами
        """
        url += '?'
        for k, v in queries.items():
            url += f'{k}={v}' if v else k
            url += '&'
        return url[:-1]

    @staticmethod
    def process_urls(urls: list) -> list:
        """
        Ищем ссылки нужного нам вида.
        * https://github.com/torvalds/linux/commit/**commit** - переделывать не надо
        * git.kernel.org - вырезаем хэш коммита и превращаем в ссылку предыдущего вида
        * остальные ссылки не меняем
        """
        result = []
        for link in urls:
            netloc = parse.urlparse(link).netloc
            path = parse.urlparse(link).path
            if netloc == 'git.kernel.org' or (netloc == 'github.com' and path.split('/')[1] == 'torvalds'):
                result.append(f'https://github.com/torvalds/linux/commit/{link.split("/")[-1].split("=")[-1]}')
            else:
                result.append(link)
        # Уберем возможные дубликаты
        result = list(set(result))
        return result

    @staticmethod
    def get_kern_patches(url: str) -> dict:
        """
        Парсим патч по ссылке, в случае, если ссылка формата
        https://github.com/torvalds/linux/commit/**commit**
        """
        netloc = parse.urlparse(url).netloc
        path = parse.urlparse(url).path
        if not (netloc == 'github.com' and path.split('/')[1] == 'torvalds'):
            return {}

        # Получим response
        new_url = f'{url}.patch'
        patch_resp = get_response(new_url, bs=True, headers=HEADERS)
        # sanity check
        if not patch_resp:
            return {}
        patch_txt = patch_resp.find('p').text

        date_re = re.compile(r"Date:\s(.+)")
        fixes_re = re.compile(r"Fixes:\s([a-z0-9]+)")
        subject_re = re.compile(r"Subject:\s(.+)")
        files_re = re.compile(r"(?<=\s-{3}\s)[\S\s]*?(?=\d+ file)")
        chgd_re = re.compile(r"(?<=\s-{3}\s)[\S\s]*?(?=\d+ file)(\d+ file.+)")
        files_raw = re.findall(files_re, patch_txt)[0].strip().split('\n')

        return {
            'date': date_re.search(patch_txt).group(1) if date_re.search(patch_txt) else None,
            'fixes': fixes_re.search(patch_txt).group(1) if fixes_re.search(patch_txt) else None,
            'subject': subject_re.search(patch_txt).group(1) if subject_re.search(patch_txt) else None,
            'files_changed': chgd_re.search(patch_txt).group(1) if chgd_re.search(patch_txt) else None,
            'files': [file.split('|')[0].strip() for file in files_raw],
            'patch_text': patch_txt,
        }

    @staticmethod
    def download_src_rpm(url, dest_path):
        req = get_response(url, bs=False)
        with open(dest_path, "wb") as f:
            for chunk in req.iter_content(100000):
                f.write(chunk)

    @staticmethod
    def get_cpe(cve):
        # Создадим (если получится), кортеж из строки, содержащей строку, из которой можно выдрать имя пакета, и
        # версию пакета, до которой уязвимо
        cpe = cve['cve'].get("configurations")
        if cpe:
            criteria = cpe[0]['nodes'][0]['cpeMatch'][0]['criteria']
            vuln_ver = [(item.get('versionStartIncluding', ''), item.get('versionEndExcluding', ''))
                        for item in cpe[0]['nodes'][0]['cpeMatch']]
            vuln_ver = [item for item in vuln_ver if item[0] or item[1]]
            cpe = (criteria, vuln_ver)
        return cpe

    def get_issue(self, name, cve, desc, links, patch_links, check_patch=True) -> dict:
        """
        Разбираем nist json на нужный нам словарь
        :param name: имя пакета, по которому мы потом будем сортировать уязвимости
        :param cve: json с уязвимостью
        :param desc: вытащеное из него описание
        :param links: обработаные URL'ы
        :param patch_links список кортежей из ссылки на явно указанный патч и хэша коммита
        :param check_patch: Будем вытаскивать патчи. Работает для ядра
        :return: словарь с разобраным добром
        """
        patch, scores = [], {}

        if check_patch:
            for link in patch_links:
                patch_resp = self.get_kern_patches(link[0])
                if patch_resp:
                    patch.append(patch_resp)

        for key in cve['cve']['metrics'].keys():
            scores[cve['cve']['metrics'][key][0]['cvssData']['version']] = \
                cve['cve']['metrics'][key][0]['cvssData']['baseScore']

        return {
            'id': cve['cve']['id'],
            'name': name,
            'description': desc,
            'published': cve['cve']['published'],
            'lastModified': cve['cve']['lastModified'],
            'status': cve['cve']['vulnStatus'],
            'links': links,
            'patch_links': patch_links,
            'scores': scores,
            'patch': patch,
            'cpe': self.get_cpe(cve),
        }

    def update_cve_field(self, query_id=None, project_id=None):
        """
        Изменяем значения поля cve, в случае если в заголовке или теле задачи есть CVE.
        номер query: 2131 - уязвимости без ядра, 2134 - уязвимости ядра включая закрытые.
        """
        project = self.redmine.issue.filter(query_id=query_id,
                                            project_id=project_id)

        search_re = re.compile(r"CVE-\d{4}-\d{4,7}", re.I)
        print_progress_bar(0, len(project), prefix='Progress:', suffix='', length=50)
        for i, issue in enumerate(project):
            test_str = issue.subject + ' ' + issue.description
            unique_cve = set(search_re.findall(test_str.lower()))
            if unique_cve:
                self.redmine.issue.update(project_id=project_id,
                                          resource_id=issue.id,
                                          custom_fields=[{
                                              'id': 334,
                                              'value': " ".join(map(str.upper, unique_cve))
                                          }])
            print_progress_bar(i, len(project), prefix='Progress:', suffix='', length=50)

    def save_cve_to_csv(self, query_id):
        """
        Выгружаем статистику по задачам и уязвимостям в CVE
        """
        project = self.redmine.issue.filter(query_id=query_id,
                                            project_id=VULN_PROJECT)
        search_re = re.compile(r"CVE-\d{4}-\d{4,7}", re.I)
        csv_header = [
            "Тема",
            "URL",
            "Статус",
            "Количество CVE",
            "Поле CVE"
        ]
        csv_data = []

        print_progress_bar(0, len(project), prefix='Progress:', suffix='', length=50)

        for i, issue in enumerate(project):
            test_str = issue.subject + ' ' + issue.description
            unique_cve = set(search_re.findall(test_str.lower()))
            csv_data.append([
                issue.subject,
                f"https://tracker.red-soft.ru/issues/{issue.id}",
                issue.status.name,
                len(unique_cve),
                issue.custom_fields.get(334).value
            ])
            print_progress_bar(i, len(project), prefix='Progress:', suffix='', length=50)

        with open(f"{CSV_PATH}/query-{query_id}.csv", 'w', encoding='UTF8', newline='') as f:
            writer = csv.writer(f, delimiter=';')
            writer.writerow(csv_header)
            writer.writerows(csv_data)

        print()
        print(f"{CSV_PATH}/query-{query_id}.csv was written")

    def update_resolved_kernel_issues(self, no_filter_kver=False):
        """
        Находит темы со строкой "following vulnerability has been resolved" и
        отвечает в ней в каких версиях ядра это было исправлено
        """
        search_issue_re = re.compile(r"following vulnerability has been resolved", re.I)
        hash_regex = r"^\* https://.+/commit/(\S+)"
        kern_ver_re = re.compile(r"^((5\.15)|(6\.[16]))\.")

        project = self.redmine.issue.filter(project_id=KERN_PROJECT)
        print_progress_bar(0, len(project), prefix='Progress:', suffix='', length=50)
        for i, issue in enumerate(project):
            print_progress_bar(i, len(project), prefix='Progress:', suffix='', length=50)
            if issue.status.id != 1 or not search_issue_re.findall(issue.description):
                continue
            matches = re.finditer(hash_regex, issue.description, re.MULTILINE)

            version_list = []
            for hash_match in matches:
                if not hash_match.groups():
                    continue
                hash_str = hash_match.group(1)
                git_cmd = f"git --git-dir={KERNEL_ML_GIT_PATH}/.git describe --contains {hash_str}"
                version_raw = self.exec_bash(git_cmd)
                version_split = version_raw.split('~')[0][1:]
                if no_filter_kver or kern_ver_re.match(version_split):
                    version_list.append((hash_str, version_split))

            if not version_list:
                continue

            str_to_post = ""
            for item in version_list:
                str_to_post += f"Исправлено начиная с версии: {item[1]}\n" \
                               f"Коммит: https://github.com/torvalds/linux/commit/{item[0]}\n\n"
            self.redmine.issue.update(project_id=KERN_PROJECT,
                                      resource_id=issue.id,
                                      notes=str_to_post,
                                      status_id=16
                                      )

    def update_bad_issues(self, query_id, project_id):
        """
        Меняет темы вида "Статус уязвимости" без полезной информации добавляя
        в нее эту самую информацию. На вход требует номер query по задачам из которого
        будет итерироваться
        """
        search_re = re.compile(r"CVE-\d{4}-\d{4,7}", re.I)
        project = self.redmine.issue.filter(query_id=query_id,
                                            project_id=project_id)

        print_progress_bar(0, len(project), prefix='Progress:', suffix='', length=50)

        global_counter = 0
        for i, issue in enumerate(project):
            change_flag = False
            if global_counter > 4:
                sleep(40)
                global_counter = 0
            print_progress_bar(i, len(project), prefix='Progress:', suffix='', length=50)
            result_subject = issue.subject
            result_description = issue.description
            test_str = issue.subject + ' ' + issue.description
            unique_cve = set(search_re.findall(test_str.lower()))
            for item in unique_cve:
                local_counter = 0
                cve_data, status = self.get_one_cve(item.upper())
                while not cve_data and not status and local_counter < 5:
                    sleep(30)
                    cve_data = self.get_one_cve(item.upper())[0]
                    local_counter += 1
                if not cve_data and not status:
                    print("Ошибка получения данных по CVE")
                    continue
                elif not cve_data and status:
                    continue
                # if cve_data['name'] != 'unknown':
                #     result_subject += f" {cve_data['name']}"
                #     change_flag = True

                cve_str = self.get_issue_str(cve_data)
                result_description += f"\n\n---\n\n{cve_str}"
                change_flag = True

                existence = self.is_cve_exists_rest_api(item.upper(), return_link=True)
                if existence[0]:
                    for iss_id in existence[1]:
                        if iss_id == str(issue.id):
                            continue
                        result_description += f"\nУпоминание уязвимости: " \
                                              f"https://tracker.red-soft.ru/issues/{iss_id}"

            if change_flag:
                self.redmine.issue.update(project_id=VULN_PROJECT,
                                          resource_id=issue.id,
                                          subject=result_subject,
                                          description=result_description,
                                          )
            global_counter += 1

    def get_one_cve(self, cve_id: str, check_patch=False, just_name=False) -> (dict, bool):
        """
        Номер в виде CVE-2023-1234 на входе, словарь с данными на выходе
        """
        params = {
            NIST_CVE: cve_id,
        }
        url = self.prepare_url(NIST_API_URL, params)
        nist_resp = get_response(url, bs=False, headers=HEADERS)
        nist_json = nist_resp.json() if nist_resp else None
        if not nist_json or not nist_json.get('vulnerabilities', ""):
            return {}, nist_resp.status_code == requests.codes.ok if nist_resp else False

        cve = nist_json.get('vulnerabilities')[0]
        desc = cve['cve']['descriptions'][0]['value'].lower()
        links = self.process_urls([link['url'] for link in cve['cve']['references']])

        patch_links = []

        for link in cve['cve']['references']:
            if link.get('tags', "") and ('patch' in map(str.lower, link['tags'])):
                prepared_link = self.process_urls([link['url']])[0]
                patch_links.append((prepared_link, self.get_hash(prepared_link)))

        name = 'unknown'
        for item in self.which_pkg(desc, links, self.get_cpe(cve)):
            key, value = *item.keys(), *item.values()
            if value == 'yes':
                name = key
            if just_name:
                return item, nist_resp.status_code == requests.codes.ok
            # print(f"{item}")

        if just_name and name == 'unknown':
            return {}, nist_resp.status_code == requests.codes.ok

        return self.get_issue(name, cve, desc, links, patch_links, check_patch=check_patch), \
            nist_resp.status_code == requests.codes.ok

    @staticmethod
    def redhat_cve_to_pkg_namelist(cve_id) -> (list, bool):
        rh_url = f"https://access.redhat.com/hydra/rest/securitydata/cve/{cve_id}.json"
        rh_resp = get_response(rh_url, bs=False, headers=HEADERS)
        rh_json = rh_resp.json() if rh_resp else None
        if not rh_json or not rh_json.get("package_state", ""):
            return [], rh_resp.status_code == requests.codes.ok if rh_resp else False

        return list(set([name.get('package_name', '') for name in rh_json['package_state']])), \
            rh_resp.status_code == requests.codes.ok

    # TODO Дублирование кода и смысла с функцией check_cve. Переписать
    def which_pkg(self, desc, links, cve) -> list:
        result = []
        for pkg_name, pkg_data in self.pkg_handler.pkgs_data.items():
            is_pkg = pkg_data['check_func'](desc, links, cve)
            if is_pkg == IsXIssue.YES:
                result.append({pkg_name: 'yes'})
            elif is_pkg == IsXIssue.MAYBE:
                result.append({pkg_name: 'maybe'})

        return result

    def check_cve(self,
                  pkg_name,
                  check_func,
                  cve,
                  desc,
                  links,
                  patch_links,
                  cve_data_list,
                  cve_id_list,
                  cve_count,
                  exists_count
                  ):
        """
        Фильтруем уязвимости на нужные/ненужные
        :param pkg_name: Имя пакета, на который проверяем
        :param check_func: Функция, которая проверяет на принадлежность к пакету
        :param cve: Словарь с данными по уязвимости
        :param desc: слегка обработанное описание уязвимости
        :param links: обработанные (в случае ядра) ссылки предоставленные nist'om
        :param patch_links: кортежи (ссылка, хэш)
        :param cve_data_list: общий список данных по отфильтрованным уязвимостям
        :param cve_id_list: общий список id отфильтрованных уязвимостей
        :param cve_count: счетчик релевантных уязвимостей
        :param exists_count: счетчик уже существующих на трекере уязвимостей
        :return: Возвращаем счетчики уязвимостей обратно
        """

        is_pkg = check_func(desc, links, cpe=self.get_cpe(cve))
        if is_pkg == IsXIssue.YES:
            cve_count += 1
            cve_id_list.append(cve['cve']['id'])
            # Проверим, заведена ли уже задача по данной CVE
            if CHECK_REDMINE and self.is_cve_exists_rest_api(cve['cve']['id'])[0]:
                exists_count += 1
                return cve_count, exists_count
            cve_data_list.append(self.get_issue(pkg_name, cve, desc, links, patch_links))
            return cve_count, exists_count

        elif is_pkg == IsXIssue.MAYBE:
            self.manual_check.append(cve['cve']['id'])

        return cve_count, exists_count

    def get_current_cves(self, date_from: str, date_to: str) -> list:
        """
        Соберем все cve между датами.
        Формат даты:
        date1 = '2023-03-01T00:00:00.000-05:00'
        date2 = '2023-03-02T23:59:59.999-05:00'
        """
        cve_data_list, cve_id_list = [], []
        exists_count = 0

        # Получим response
        params = {
            NIST_REJ: None,
            NIST_START: date_from,
            NIST_END: date_to
        }
        url = self.prepare_url(NIST_API_URL, params)
        # В качестве header-ов передаем стандартные плюс ключ api NIST-a
        nist_resp = get_response(url, bs=False, headers=dict(HEADERS, **{'apiKey': credentials['NIST_KEY']}))

        nist_json = nist_resp.json() if nist_resp else None
        if not nist_json or not nist_json.get('vulnerabilities', ""):
            return []

        total_res = nist_json['totalResults']
        print(f'Total CVE found:          {total_res}')
        for cve in nist_json.get('vulnerabilities'):

            if cve['cve']['id'] in cve_id_list:
                continue

            # подготовим данные для проверки
            desc = cve['cve']['descriptions'][0]['value'].lower()
            links = self.process_urls([link['url'] for link in cve['cve']['references']])

            patch_links = []

            for link in cve['cve']['references']:
                if link.get('tags', "") and ('patch' in map(str.lower, link['tags'])):
                    prepared_link = self.process_urls([link['url']])[0]
                    patch_links.append((prepared_link, self.get_hash(prepared_link)))

            # rh_check = self.redhat_cve_to_pkg_namelist(cve['cve']['id'])
            # rh_found = False
            # if rh_check[1]:
                # for rh_name in rh_check[0]:
                    # if rh_name == 'kernel':
                        # rh_name = 'kernel-lt'
                    # stapel_data = [self.pkg_handler.get_latest_rpm_data(rh_name, tag[0], tag[1]).get('version', "")
                                   # for tag in self.pkg_handler.tags]
                    # if not stapel_data:
                        # continue
                    # if not cve['cve']['id'] in cve_id_list:
                        # cve_id_list.append(cve['cve']['id'])
                    # else:
                        # continue
                    # rh_found = True

                    # if CHECK_REDMINE and self.is_cve_exists_rest_api(cve['cve']['id'])[0]:
                        # break

                    # cve_data_list.append(self.get_issue(rh_name, cve, desc, links, patch_links))
                    # if not self.pkg_handler.pkgs_data.get(rh_name, ""):
                        # self.pkg_handler.pkgs_data[rh_name] = {
                            # 'check_func': None,
                            # 'cve_counter': 1,
                            # 'stapel_name': rh_name,
                            # 'nvr_list': stapel_data,
                            # 'check_patch': True,
                            # 'assigned_to': int(self.pkg_handler.users_dict['vladimir.chirkin']),
                        # }
                    # else:
                        # self.pkg_handler.pkgs_data[rh_name]['cve_counter'] += 1

            # if rh_found:
                # continue

            for pkg_name, pkg_data in self.pkg_handler.pkgs_data.items():
                pkg_data['cve_counter'], exists_count = self.check_cve(pkg_name,
                                                                       pkg_data['check_func'],
                                                                       cve,
                                                                       desc,
                                                                       links,
                                                                       patch_links,
                                                                       cve_data_list,
                                                                       cve_id_list,
                                                                       pkg_data['cve_counter'],
                                                                       exists_count)

        moz_cves = self.get_mozilla_cves()
        for moz_advisories in moz_cves:
            for cve in moz_advisories['cves']:
                if CHECK_REDMINE and not self.is_cve_exists_rest_api(cve['id'])[0]:
                    cve_data_list.append(cve)
                    cve_id_list.append(cve['id'])
                    self.pkg_handler.pkgs_data[cve['name']]['cve_counter'] += 1

        chrome_cves = self.get_chrome_cves()
        for cve in chrome_cves:
            if CHECK_REDMINE and not self.is_cve_exists_rest_api(cve['id'])[0]:
                cve_data_list.append(cve)
                cve_id_list.append(cve['id'])
                self.pkg_handler.pkgs_data[cve['name']]['cve_counter'] += 1

        print('-' * 80)
        print(f"CVE for {len(self.pkg_handler.pkgs_data)} packages")
        print('-' * 80)
        for pkg_name, pkg_data in self.pkg_handler.pkgs_data.items():
            if not pkg_data['cve_counter']:
                continue
            # классная арифметическая конструкция - для вычисления пробелов
            print(f"{pkg_name}:" + " " * (30 - (len(pkg_name) + 5)) + f"{pkg_data['cve_counter']}")
        print('-' * 80)
        print(f"CVE list:                 {cve_id_list[0] if cve_id_list else ''}")
        if cve_id_list and len(cve_id_list) > 1:
            for item in cve_id_list[1:]:
                print(f"{26 * ' '}{item}")
        if self.manual_check:
            print("Manual check:", end='')
            for n, item in enumerate(self.manual_check):
                space_num = 13 if n == 0 else 26
                print(f"{space_num * ' '}https://nvd.nist.gov/vuln/detail/{item}")
        print(f"CVE existed on a tracker: {exists_count}")
        return cve_data_list

    @staticmethod
    def get_issue_str(cve: dict) -> str:
        """
        Формирует строку для последующего создания темы на трекере
        """
        result = ""
        result += f"*Уязвимость {cve['id']}*\n\n"
        result += f"Описание:\n"
        result += f"{cve['description']}\n\n"
        if cve.get('scores', ""):
            result += f'Важность:\n'
            for k, v in cve['scores'].items():
                result += f"* *CVSS {k}: {v}*\n"
        elif cve.get('impact', ""):
            result += f'Важность:\n'
            result += f"* *{cve['impact']}*\n\n"
        if cve.get('fixed_in', ""):
            result += f'Исправлено:\n'
            result += f"* *{cve['fixed_in']}*\n"
        if cve.get('cpe', "") and cve['cpe'][1]:
            result += f"\nУязвимые версии:\n"
            for item in cve['cpe'][1]:
                result += f"* {'от ' + item[0] + ' ' if item[0] else ''}" \
                          f"{'до ' + item[1] if item[1] else ''}\n"
        if cve.get('patch', ""):
            for i, item in enumerate(cve['patch'], start=1):
                result += f'\nДанные патча №{i}:\n\n'
                result += f"* Дата: {item['date']}\n"
                if item['fixes']:
                    result += f"* Уязвимый коммит: https://github.com/torvalds/linux/commit/" \
                              f"{item['fixes']}\n"
                result += f"* Тема: {item['subject']}\n"
                result += f"* Изменения: {item['files_changed']}\n"
                result += f"\nФайл(ы):\n\n"
                for filename in item['files']:
                    result += f"* *{filename}*\n"
        if cve.get('links'):
            result += f"\nСсылки:\n\n"
            for link in cve['links']:
                result += f"* {link}\n"
        if cve.get('source', ""):
            result += f"\nИсточник:\n\n"
            result += f"* {cve['source']}\n\n"
        else:
            result += f"\nИсточник:\n\n"
            result += f"* https://nvd.nist.gov/vuln/detail/{cve['id']}\n\n"
        result += "---\n\n"
        return result

    def create_an_issue(self,
                        subject,
                        project_id,
                        desc: str,
                        cve: str,
                        assigned_id=23,
                        watcher_ids=None,
                        tag=None,
                        ):
        """
        Создает тему на трекере.
        :param subject: Тема задачи
        :param project_id: Номер проекта, в котором создаем задачу
        :param desc: Описание
        :param cve: Номер уязвимости для
        заполнения соответствующего поля
        :param assigned_id: кому назначена
        :param watcher_ids: Кто наблюдатель
        :param tag: тег
        :return: id задачи
        """
        try:
            issue = self.redmine.issue.create(
                project_id=project_id,  # 297 Уязвимости, 787 - подпроект kernel
                subject=subject,  # заголовок
                tracker_id=10,  # 10 - класс "Задача"
                description=desc,  # тело задачи
                status_id=1,  # 1 - новая
                fixed_version_id=146,  # 146 - Версия: РЕД ОС - РЕД ОС 7.3
                priority_id=1,  # 1 - нормальный приоритет
                assigned_to_id=assigned_id,
                watcher_user_ids=watcher_ids,
                custom_fields=[{'id': 151, 'value': 'Все'},  # Конфигурация ОС: Все
                               {'id': 133, 'value': ['143', '144']},
                               # 143, 144 - Редакция: Сертифицированная, Стандартная
                               {'id': 334, 'value': cve},  # номер уязвимости
                               ],
                tag_list=[
                    tag  # Метка: например kernel
                ],
            )
            return issue.id
        except redminelib.exceptions.ValidationError as err:
            print(f"Can't create an issue: {err}")
            exit(1)

    @staticmethod
    def apply_patches(src_path, patch_path) -> PatchResult:
        """
        Пытаемся применить патч к требуемому дереву сорцов.
        """

        ps = subprocess.Popen(f"patch -p 1 --dry-run < {patch_path}",
                              shell=True,
                              cwd=src_path,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        git_status = ps.communicate()[0].decode('utf-8')
        if 'FAILED' in git_status:
            return PatchResult.FAILED
        elif 'previously applied' in git_status:
            return PatchResult.ALREADY_APPLIED
        elif "can't find file" in git_status:
            return PatchResult.NO_FILE
        else:
            return PatchResult.SUCCESS

    def prepare_issue(self, cve_list, pkg_name, check_patch=False):
        """
        Подготавливаем строки для создания задачи в трекере либо для печати в stdout
        :param cve_list: список подготовленных словарей
        :param pkg_name: имя пакета, для которого собраны уязвимости
        :param check_patch: флаг, что мы хотим проверять патчи. Пока только для ядра
        :return: возвращаем строку, список найденых патчей и удачных применений патчей
        """
        issues_lst = []
        patches_found = 0
        successful_patches_list = []

        for single_cve in cve_list:
            issue_str = ""
            issue_str += self.get_issue_str(single_cve)

            if not single_cve.get('patch', "") and not check_patch:
                if issue_str:
                    issue_str += self.print_nvrs(pkg_name)
                    issues_lst.append(issue_str)
                continue
            patches_found += 1
            for i, patch in enumerate(single_cve['patch'], start=1):
                patch_path = f"{TMP_PATCHES_PATH}/000{i}_{single_cve['id']}.patch"
                with open(patch_path, "w") as f:
                    f.write(patch['patch_text'])
                # Пробуем применить патч к разным версиям ядра
                if CHECK_PATCH:
                    issue_str += f"Актуальность патча №{i}:\n\n"

                    for kern_path in set(self.kernel_paths):
                        current_ver = re.findall(r"linux-(\d\.\d+\.\d+)", kern_path)[0]
                        patching_result = self.apply_patches(kern_path, patch_path)
                        issue_str += f"Для версии {current_ver}:\n"

                        if patching_result == PatchResult.FAILED:
                            issue_str += "* Не удалось применить\n\n"
                        elif patching_result == PatchResult.ALREADY_APPLIED:
                            issue_str += "* Уже применен\n\n"
                        elif patching_result == PatchResult.NO_FILE:
                            issue_str += "* Нет файла для применения\n\n"
                        elif patching_result == PatchResult.SUCCESS:
                            issue_str += "* Применен успешно\n\n"
                            successful_patches_list.append((patch_path,
                                                            single_cve['id'],
                                                            current_ver))

            if issue_str:
                issue_str += self.print_nvrs(pkg_name)
                issues_lst.append(issue_str)

        return issues_lst, patches_found, successful_patches_list

    def print_nvrs(self, pkg_name: str) -> str:
        result = ''
        if pkg_name not in self.pkg_handler.pkgs_data.keys():
            return result
        for tag, pkg_data in zip(self.pkg_handler.tags, self.pkg_handler.pkgs_data[pkg_name]['nvr_list']):
            result += f"Версия пакета для {tag[0]['name']:<20}" \
                      f"{self.pkg_handler.pkgs_data[pkg_name]['stapel_name']:>5}-{pkg_data}\n"
        return result

    def print_parsers(self):
        print(f"Number of parsers:   {len(self.pkg_handler.pkgs_data)}")
        print(50 * "-")
        for pkg_name, pkg_data in self.pkg_handler.pkgs_data.items():
            print(f"{pkg_name:<20} -> {pkg_data['stapel_name']:<5}")

    def show_maintainers(self):
        with open(USERS_LIST) as f:
            users_dict = json.loads(f.read())
            inv_users = {v: k for k, v in users_dict.items()}
        for _, pkg_data in self.pkg_handler.pkgs_data.items():
            print(f"{pkg_data['stapel_name']:<40} -> {inv_users[pkg_data['assigned_to']]:<5}")

    def show_pkgs_for_maintainer(self, user):
        result = []
        with open(USERS_LIST) as f:
            users_dict = json.loads(f.read())
        for _, pkg_data in self.pkg_handler.pkgs_data.items():
            if pkg_data['assigned_to'] == users_dict[user]:
                result.append(pkg_data['stapel_name'])

        if result:
            print(f"for user {user} found {len(result)} package(s):")
            print(45 * "-")
            for item in result:
                print(f"* {item}")
        else:
            print(f"No packages found for user: {user}")

    @staticmethod
    def get_github_advisory(ghsa_id):
        headers = {
            "Accept": "application/vnd.github+json",
            "Authorization": f"Bearer {credentials['GITHUB_TOKEN']}",
            "X-GitHub-Api-Version": "2022-11-28"
        }
        url = f"https://api.github.com/advisories/{ghsa_id}"
        resp = get_response(url,
                            bs=False,
                            parser='xml',
                            headers=headers,
                            verify=False
                            )
        # TODO | github'овское API достаточно богато на информацию,
        # TODO | в том числе на имя пакета. Можно это использовать
        result = resp.json() if resp else None
        if result is None:
            return ghsa_id
        return result['cve_id'] if result.get('cve_id', '') else ghsa_id

    @staticmethod
    def get_json_data(data) -> list:
        result = []
        for item in data:
            current_vuln_id = item.get("ID", "")
            if current_vuln_id and current_vuln_id != 'none':
                result.append(current_vuln_id)
        return result

    def get_luntry_cve(self, luntry_path) -> list:
        vuln_list = []
        for path, subdirs, files in os.walk(os.path.expanduser(luntry_path)):
            for name in files:
                if name.endswith('.json'):
                    file_name = os.path.join(path, name)
                    with open(file_name) as json_file:
                        json_data = json.load(json_file)
                        vuln_list.extend(self.get_json_data(json_data))
        vuln_list = set(vuln_list)
        vuln_list = [self.get_github_advisory(item)
                     if item.split('-')[0] == 'GHSA'
                     else item for item in vuln_list]
        return list(sorted(vuln_list))

    def check_luntry_jsons(self, luntry_path: str):
        luntry_cve_list = self.get_luntry_cve(luntry_path)
        print(75 * "-")
        print(f"Number of IDs: {len(luntry_cve_list)}")
        print(75 * "-")
        print()
        for item in luntry_cve_list:
            if item.split('-')[0] == 'GHSA':
                print(f"{item} -> https://github.com/advisories/{item}")
                print(75 * "-")
            elif item.split('-')[0] == 'CVE':
                existence, tracker_ids = self.is_cve_exists_rest_api(item, return_link=True)
                print(f"ID:      {item}")
                print(f"EXISTS:  {existence}")
                # what_pkg = self.get_one_cve(item, just_name=True)
                # if what_pkg:
                #     key, value = *what_pkg.keys(), *what_pkg.values()
                #     print(f"PKG:     {key}")
                #     print(f"CERTAIN: {value}")

                print(f"NIST:    https://nvd.nist.gov/vuln/detail/{item}")
                if tracker_ids:
                    print()
                    print("TRACKER")
                    for tracker_id in tracker_ids:
                        print(f"         https://tracker.red-soft.ru/issues/{tracker_id}")
                print(75 * "-")
            else:
                continue

    def get_stable_hashes(self, resp, hash_flag=False):
        def check_hash(hash_str: str) -> (str, str):
            short_hsh = hash_str[:7] if len(hash_str) > 7 else ""
            check_list = [
                f"commit {hash_str} upstream",
                f"upstream commit {hash_str}",
                f"upstream {hash_str} commit",
                f"commit {short_hsh} upstream" if short_hsh else "",
                f"upstream commit {short_hsh}" if short_hsh else "",
                f"upstream {short_hsh} commit" if short_hsh else "",
            ]
            check_list = [item for item in check_list if item]
            for check_item in check_list:
                git_search_commit_str = (f'git -C {kern_path} log -1 --all --grep="{check_item}" '
                                         f'-i --format=format:"%H"')
                hash_resp = self.exec_bash(git_search_commit_str)
                if hash_resp:
                    git_describe_hash = f'git -C {kern_path} describe --contains {hash_resp}'
                    contains_resp = self.exec_bash(git_describe_hash)
                    return contains_resp.split('~')[0][1:], hash_resp

            return "", ""

        result = {}
        if not hash_flag:
            hash_set = set([hsh[1] for hsh in resp['patch_links'] if hsh[1]])
        else:
            hash_set = set([resp])

        for long_hsh in hash_set:
            tmp_dict = {}
            for kern_str, kern_path in KERN_PATH_DICT.items():
                git_describe_hash = f'git -C {kern_path} describe --contains {long_hsh}'
                hash_resp = self.exec_bash(git_describe_hash)
                if hash_resp:
                    tmp_dict[kern_str] = {
                        "kern": hash_resp.split('~')[0][1:],
                        "hash": long_hsh,
                    }
                    continue

                contains_str, hash_str = check_hash(long_hsh)
                if contains_str:
                    tmp_dict[kern_str] = {
                        "kern": contains_str,
                        "hash": hash_str,
                    }
                    continue

                tmp_dict[kern_str] = 'not found'

            result[long_hsh] = tmp_dict

        return result

    @staticmethod
    def find_all_issues(n=50):
        """
        Сканируем трекер, собираем большинство уязвимостей и печатаем n популярных
        """

        def title_strip(title):
            regex1 = re.compile(r"уязвимость в (.+)$", re.I)
            regex2 = re.compile(r"уязвимости в (.+)$", re.I)
            regex3 = re.compile(r"уязвимость: (.+)$", re.I)
            title_reg = re.findall(regex1, title.text)
            title_reg.extend(re.findall(regex2, title.text))
            title_reg.extend(re.findall(regex3, title.text))
            if title_reg:
                return title_reg[0].strip().lower()

        # ниже идут функции проверки на принадлежность к пакету
        def kernel_str(str_to_check: str) -> str:
            kw_list = [
                'ядро linux',
                'ядру linux',
                'ядра linux',
                'ядре linux',
                'linux-ядра',
            ]
            for kw in kw_list:
                if kw in str_to_check:
                    return 'linux kernel'
            return str_to_check

        def firefox_str(str_to_check: str) -> str:
            return 'firefox' if 'firefox' in str_to_check else str_to_check

        def systemd_str(str_to_check: str) -> str:
            return 'systemd' if 'systemd' in str_to_check else str_to_check

        def nextcloud_str(str_to_check: str) -> str:
            return 'nextcloud' if 'nextcloud' in str_to_check else str_to_check

        def thunderbird_str(str_to_check: str) -> str:
            return 'thunderbird' if 'thunderbird' in str_to_check else str_to_check

        def curl_str(str_to_check: str) -> str:
            kw_list = [
                'curl',
                'libcurl',
            ]
            for kw in kw_list:
                if kw in str_to_check:
                    return 'curl'
            return str_to_check

        # список из этих функций, чтобы было удобнее итерироваться
        filter_funcs = [
            kernel_str,
            firefox_str,
            systemd_str,
            nextcloud_str,
            thunderbird_str,
            curl_str,
        ]

        limit = 100
        # для того, чтобы пройти все страницы с найденными темами потребуется счетчик для оффсета
        cnt = 0
        result = []
        while True:
            url = f"{REDMINE_URL}/projects/cve/search.xml?&issues=1&" \
                  f"limit={limit}&offset={cnt}&titles_only=1&q=уязвимост"
            resp = get_response(url,
                                bs=True,
                                parser='xml',
                                headers=HEADERS,
                                auth=(credentials['REDMINE_USER'],
                                      credentials['REDMINE_PASSWORD']),
                                verify=False
                                )
            titles = resp.find_all("title")
            t_count = len(titles)
            result.extend(list(map(title_strip, titles)))
            result = list(filter(lambda x: x is not None, result))
            for func in filter_funcs:
                result = list(map(func, result))
            cnt += limit
            if t_count < limit:
                break

        for item in Counter(result).most_common(n):
            print(f"{item[0]:<20} {item[1]:>5}")

    @staticmethod
    def send_to_telegram(message: str) -> dict:
        """
        Послать строку в телеграм
        :param message: строка, которую посылаем
        :return: Возвращает ответ от телеги в случае успеха
        """
        group_id = credentials['TELEGRAM_GROUP_ID']
        bot_token = credentials['BOT_TOKEN']
        send_command = f"curl -s --data 'text={message}' --data 'chat_id={group_id}' " \
                       f"'https://api.telegram.org/bot'{bot_token}'/sendMessage'"
        ps = subprocess.Popen(send_command,
                              shell=True,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        result = ps.communicate()[0].decode('utf-8')
        return json.loads(result) if result else {}

    def check_patches(self, kern_path, patch_path):
        if kern_path:
            kern_paths = [os.path.expanduser(kern_path)]
        else:
            kern_paths = self.kernel_paths

        patch_paths = os.path.expanduser(patch_path) if patch_path else DEST_PATCH_PATH
        for subdir, dirs, files in os.walk(patch_paths):
            if not files:
                continue

            for path in kern_paths:
                checked_list = []
                print()
                # print(120 * "=")
                # print(f"Патчи из {subdir.split('/')[-1]} для ядра {re.findall(self.ver_re, path)[0]}")
                print(120 * "=")
                for file in files:
                    patch_path = os.path.join(subdir, file)
                    check_result = self.apply_patches(path, patch_path)
                    checked_list.append((file, check_result))
                for item in sorted(checked_list, key=lambda x: x[1].value):
                    print(f"{item[0]:<85} -> {item[1]:^20}")

    def check_and_post(self,
                       pkg_name,
                       all_cves,
                       check_patch: bool,
                       assigned_id=23,  # 23 - Владимир Чиркин
                       watcher_ids=None,
                       ):
        """
        Подготавливаем к печати/публикованию уязвимости, собранные на предыдущем этапе.
        Разделяем по пакетам: ядро, вим и т.д.
        :param pkg_name: Имя пакета
        :param all_cves: Полный список отобранных cve
        :param check_patch: Проверяли патчи или нет
        :param assigned_id: Кому назначено
        :param watcher_ids: Кто наблюдатели (в виде list'a)
        :return:
        """

        pkg_cves = list(filter(lambda x: x['name'] == pkg_name, all_cves))
        issues, patches_found, successful_patches_list = self.prepare_issue(pkg_cves,
                                                                            pkg_name,
                                                                            check_patch=check_patch)
        if check_patch:
            print(f"{pkg_name} patches found:     {patches_found}\n")
        if issues:
            for item in issues:
                print(item, "\n")
        if not (CREATE_AN_ISSUE and pkg_cves and self.redmine):
            return
        if not self.auto and not self.user_wants_create_issue():
            return

        for i, issue in enumerate(issues):
            subject = f'Уязвимость {pkg_name} {pkg_cves[i].get("id", "")}'
            try:
                issue_id = self.create_an_issue(subject=subject,
                                                desc=issue,
                                                project_id=KERN_PROJECT if pkg_name == 'kernel' else VULN_PROJECT,
                                                cve=pkg_cves[i].get("id", ""),
                                                assigned_id=assigned_id,
                                                watcher_ids=watcher_ids,
                                                tag=pkg_name if pkg_name == 'kernel' else None)

                print(f"Создана задача № {issue_id}")
                issue_url = f"{REDMINE_URL}/issues/{issue_id}"
                print(issue_url)

                if SEND_TO_TELEGRAM:
                    # self.manual_check = list(map(lambda x: f"https://nvd.nist.gov/vuln/detail/{x}",
                    #                              self.manual_check))
                    # manual_check_str = '\n'.join(self.manual_check)
                    # self.send_to_telegram(f"{subject}\nManual check:"
                    #                       f" {manual_check_str}\nTracker URL: {issue_url}")
                    self.send_to_telegram(f"\nSubject: {subject}\nTracker URL: {issue_url}")
            except:
                print("For some reason can't create an issue")
                continue

        if successful_patches_list and SAVE_PATCHES:
            # чтобы итерироваться каждый раз по разным версиям, вместо общего счетчика
            for ver in set(map(lambda x: x[2], successful_patches_list)):
                for i, item in enumerate(list(filter(lambda x: x[2] == ver, successful_patches_list)),
                                         start=1):
                    dest_patch = f"{DEST_PATCH_PATH}/patches-{item[2]}/" \
                                 f"000{i}_kernel-lt-{item[2]}_{item[1]}.patch"
                    shutil.copyfile(item[0], dest_patch)
                    print(f"Patch created: {dest_patch}")

    def run(self):
        """
        Основной цикл
        """
        all_cves = self.get_current_cves(*self.get_dates(today=not bool(START_DATE)))
        for pkg_name, pkg_data in self.pkg_handler.pkgs_data.items():
            self.check_and_post(pkg_name,
                                all_cves,
                                check_patch=pkg_data['check_patch'],
                                assigned_id=pkg_data['assigned_to'],
                                watcher_ids=pkg_data['watchers'])

    def __del__(self):
        for path in [TMP_SRPM_PATH, TMP_PATCHES_PATH]:
            if os.path.exists(path):
                shutil.rmtree(path, ignore_errors=False, onerror=None)


def parse_args():
    parser = argparse.ArgumentParser(
        description="Скрипт для парсинга Linux Kernel CVE, поиска патчей и создания темы на трекере")

    parser.add_argument(
        '-d',
        '--day',
        type=int,
        default=1,
        help="Количество дней за которые смотрим уязвимости."
    )
    parser.add_argument(
        '--start-date',
        type=str,
        default='',
        help="С какой даты ищем cve. Формат dd-mm-YYYY"
    )
    parser.add_argument(
        '--cve',
        type=str,
        help="Вывести в консоль данные по конкретной CVE"
    )
    parser.add_argument(
        '--exists',
        action='store_true',
        help="Проверяем, есть ли такая тема на трекере. В случае если не проверяем, "
             "тема создаваться не будет."
    )
    parser.add_argument(
        '--no-exists',
        dest='exists',
        action='store_false',
    )
    parser.add_argument(
        '--patch-check',
        action='store_true',
        help="Проверять патч на локальных сорцах ядра требуемой версии"
    )
    parser.add_argument(
        '--no-patch-check',
        dest='patch_check',
        action='store_false',
    )
    parser.add_argument(
        '--auto',
        action='store_true',
        help="Автоматическое создание темы или спрашиваем у юзера"
    )
    parser.add_argument(
        '--no-auto',
        dest='auto',
        action='store_false',
    )
    parser.add_argument(
        '--send',
        action='store_true',
        help="Посылаем тему в телегу или нет."
    )
    parser.add_argument(
        '--no-send',
        dest='send',
        action='store_false',
    )
    parser.add_argument(
        '--tracker',
        action='store_true',
        help="Создаем тему или нет."
    )
    parser.add_argument(
        '--no-tracker',
        dest='tracker',
        action='store_false',
    )
    parser.add_argument(
        '--users',
        action='store_true',
        help="Создать файл со списком юзеров редмайна"
    )
    parser.add_argument(
        '--zero',
        action='store_true',
        help="тестовый флаг для зеродэй парсинга"
    )
    parser.add_argument(
        '--nvr',
        type=str,
        help="Вывести в консоль данные по пакету"

    )
    parser.add_argument(
        '--check-patches',
        type=str,
        action='append',
        nargs=2,
        help="Проверить на указанных сорцах указанную папку с патчами"
    )
    parser.add_argument(
        '--current-parsers',
        action='store_true',
        help="Вывести текущие парсеры"
    )
    parser.add_argument(
        '--show-maintainers',
        action='store_true',
        help="Вывести текущих сборщиков"
    )
    parser.add_argument(
        '--show-pkgs-for-maintainer',
        type=str,
        default='',
        help="Вывести пакеты, которые назначаются на конкретного человека. Формат: ivan.ivanov"
    )
    parser.add_argument(
        '--check-luntry-jsons',
        type=str,
        default='',
        help="Проверить папку с результатами работы сканера luntry"
    )
    parser.add_argument(
        '--stat',
        action='store_true',
        help="Статистика по уязвимостям на трекере"
    )
    parser.add_argument(
        '--cve-to-csv',
        type=int,
        help="Сохранить отчет по заданному query в csv"
    )
    parser.add_argument(
        '--update-cve-field',
        type=int,
        action='append',
        nargs='+',
        help="Обновить поле CVE на основе темы и описания. Требует номер query и номер проекта"
    )
    parser.add_argument(
        '--update-resolved',
        action='store_true',
        help="Проходит по созданным темам (фильтрует по паттерну) и пытается написать в каком коммите побеждено"
    )
    parser.add_argument(
        '--update-bad-issues',
        type=int,
        action='append',
        nargs='+',
        help="Обновляет некорректно созданные задачи вида 'Статус уязвимости'. Требует номер query и проекта"
    )
    parser.add_argument(
        '--get-stable-hashes',
        type=str,
        help="Получить по номеру CVE хэши ML и стабильных веток и версии с которых исправлено"
    )
    parser.add_argument(
        '--test-chrome',
        type=str,
        help=""
    )
    parser.add_argument(
        '--test-rh-api',
        type=str,
        help=""
    )

    parser.set_defaults(exists=True)
    parser.set_defaults(tracker=True)
    parser.set_defaults(auto=True)
    parser.set_defaults(patch_check=True)
    parser.set_defaults(send=True)
    parser.set_defaults(users=False)
    parser.set_defaults(moz=False)
    parser.set_defaults(zero=False)
    parser.set_defaults(stat=False)
    parser.set_defaults(current_parsers=False)
    parser.set_defaults(show_maintainers=False)
    parser.set_defaults(update_resolved=False)
    return parser.parse_args()


if __name__ == '__main__':
    arguments = parse_args()
    DAYS_TO_CHECK = arguments.day
    SEND_TO_TELEGRAM = arguments.send
    CHECK_REDMINE = arguments.exists
    CHECK_PATCH = arguments.patch_check
    STAT = arguments.stat
    CREATE_AN_ISSUE = arguments.tracker and CHECK_REDMINE
    AUTO = arguments.auto
    CVE = arguments.cve
    USERS = arguments.users
    START_DATE = arguments.start_date
    if arguments.update_cve_field:
        UPDATE_ARGS = flatten_chain(arguments.update_cve_field)
    else:
        UPDATE_ARGS = None

    if arguments.update_bad_issues:
        UPDATE_ISSUES_ARGS = flatten_chain(arguments.update_bad_issues)
    else:
        UPDATE_ISSUES_ARGS = None

    if arguments.check_patches:
        CHECK_PATCHES_ARG = flatten_chain(arguments.check_patches)
    else:
        CHECK_PATCHES_ARG = None

    if USERS:
        get_users_list()
        exit(0)

    cve_checker = CveChecker(DAYS_TO_CHECK, NUMBER_OF_RECON, AUTO)
    if CVE:
        one_cve = cve_checker.get_one_cve(CVE, check_patch=True)[0]
        if one_cve:
            print(f"Package exists on tracker: "
                  f"{cve_checker.is_cve_exists_rest_api(CVE, return_link=True)[0]}")
            print(80 * '-')
            print(cve_checker.get_issue_str(one_cve))
            exit(0)
        else:
            print("CVE not found")
            exit(0)
    if STAT:
        cve_checker.find_all_issues()
        exit(0)
    if arguments.zero:
        cve_checker.get_zero_cves()
        exit(0)
    if arguments.cve_to_csv:
        cve_checker.save_cve_to_csv(arguments.cve_to_csv)
        exit(0)
    if arguments.update_resolved:
        cve_checker.update_resolved_kernel_issues(no_filter_kver=True)
        exit(0)

    if UPDATE_ISSUES_ARGS:
        if len(UPDATE_ISSUES_ARGS) == 2:
            cve_checker.update_bad_issues(query_id=UPDATE_ISSUES_ARGS[0],
                                          project_id=UPDATE_ISSUES_ARGS[1])
        else:
            print("Wrong arguments number")
            exit(1)
        exit(0)

    if arguments.test_rh_api:
        print(cve_checker.redhat_cve_to_pkg_namelist(arguments.test_rh_api))
        exit(0)
    if arguments.test_chrome:
        # print(cve_checker.get_chrome_cves(arguments.test_chrome))
        test_str = cve_checker.create_chromecve('https://chromereleases.googleblog.com/2024/07/stable-channel-update-for-desktop_23.html')
        exit(0)
    if arguments.get_stable_hashes:
        search_re = re.compile(r"CVE-\d{4}-\d{4,7}", re.I)
        hash_flag = not bool(search_re.findall(arguments.get_stable_hashes))
        if not hash_flag:
            resp = cve_checker.get_one_cve(cve_id=arguments.get_stable_hashes)
            if not resp[1]:
                print("Service unavailable")
                exit(0)
            else:
                resp = resp[0]
        else:
            resp = arguments.get_stable_hashes

        res_hash = cve_checker.get_stable_hashes(resp, hash_flag=hash_flag)
        for _, hash_dict in res_hash.items():
            for k, v in hash_dict.items():
                if isinstance(v, dict):
                    print(f"{k}: Исправлено начиная с: {v['kern']} "
                          f"\n\n* Коммит: https://github.com/torvalds/linux/commit/{v['hash']}\n")
                else:
                    print(f"{k}: {v}\n")
        exit(0)
    if UPDATE_ARGS:
        if len(UPDATE_ARGS) == 2:
            cve_checker.update_cve_field(query_id=UPDATE_ARGS[0],
                                         project_id=UPDATE_ARGS[1])
        elif len(UPDATE_ARGS) == 1:
            cve_checker.update_cve_field(project_id=UPDATE_ARGS[0])
        else:
            print("Wrong arguments number")
            exit(1)
        exit(0)
    if arguments.nvr:
        nvr_data = cve_checker.print_nvrs(arguments.nvr)
        if nvr_data:
            print(nvr_data)
        exit(0)
    if CHECK_PATCHES_ARG:
        cve_checker.check_patches(CHECK_PATCHES_ARG[0], CHECK_PATCHES_ARG[1])
        exit(0)
    if arguments.current_parsers:
        cve_checker.print_parsers()
        exit(0)
    if arguments.show_maintainers:
        cve_checker.show_maintainers()
        exit(0)
    if arguments.show_pkgs_for_maintainer:
        cve_checker.show_pkgs_for_maintainer(arguments.show_pkgs_for_maintainer)
        exit(0)
    if arguments.check_luntry_jsons:
        cve_checker.check_luntry_jsons(arguments.check_luntry_jsons)
        exit(0)
    print(80 * "=")
    if START_DATE:
        print(f"Start date:               {START_DATE}")
    else:
        print(f"Current time:             {datetime.now().strftime('%H:%M:%S %d-%m-%Y')}")
    print(f"Checking CVE's for:       {DAYS_TO_CHECK} day(s)")
    cve_checker.run()
    print(80 * "=")
